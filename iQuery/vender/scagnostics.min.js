(function () {
	'use strict';

	var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var underscore = createCommonjsModule(function (module, exports) {
	//     Underscore.js 1.9.1
	//     http://underscorejs.org
	//     (c) 2009-2018 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	//     Underscore may be freely distributed under the MIT license.

	(function() {

	  // Baseline setup
	  // --------------

	  // Establish the root object, `window` (`self`) in the browser, `global`
	  // on the server, or `this` in some virtual machines. We use `self`
	  // instead of `window` for `WebWorker` support.
	  var root = typeof self == 'object' && self.self === self && self ||
	            typeof commonjsGlobal == 'object' && commonjsGlobal.global === commonjsGlobal && commonjsGlobal ||
	            this ||
	            {};

	  // Save the previous value of the `_` variable.
	  var previousUnderscore = root._;

	  // Save bytes in the minified (but not gzipped) version:
	  var ArrayProto = Array.prototype, ObjProto = Object.prototype;
	  var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;

	  // Create quick reference variables for speed access to core prototypes.
	  var push = ArrayProto.push,
	      slice = ArrayProto.slice,
	      toString = ObjProto.toString,
	      hasOwnProperty = ObjProto.hasOwnProperty;

	  // All **ECMAScript 5** native function implementations that we hope to use
	  // are declared here.
	  var nativeIsArray = Array.isArray,
	      nativeKeys = Object.keys,
	      nativeCreate = Object.create;

	  // Naked function reference for surrogate-prototype-swapping.
	  var Ctor = function(){};

	  // Create a safe reference to the Underscore object for use below.
	  var _ = function(obj) {
	    if (obj instanceof _) return obj;
	    if (!(this instanceof _)) return new _(obj);
	    this._wrapped = obj;
	  };

	  // Export the Underscore object for **Node.js**, with
	  // backwards-compatibility for their old module API. If we're in
	  // the browser, add `_` as a global object.
	  // (`nodeType` is checked to ensure that `module`
	  // and `exports` are not HTML elements.)
	  if (!exports.nodeType) {
	    if (!module.nodeType && module.exports) {
	      exports = module.exports = _;
	    }
	    exports._ = _;
	  } else {
	    root._ = _;
	  }

	  // Current version.
	  _.VERSION = '1.9.1';

	  // Internal function that returns an efficient (for current engines) version
	  // of the passed-in callback, to be repeatedly applied in other Underscore
	  // functions.
	  var optimizeCb = function(func, context, argCount) {
	    if (context === void 0) return func;
	    switch (argCount == null ? 3 : argCount) {
	      case 1: return function(value) {
	        return func.call(context, value);
	      };
	      // The 2-argument case is omitted because we’re not using it.
	      case 3: return function(value, index, collection) {
	        return func.call(context, value, index, collection);
	      };
	      case 4: return function(accumulator, value, index, collection) {
	        return func.call(context, accumulator, value, index, collection);
	      };
	    }
	    return function() {
	      return func.apply(context, arguments);
	    };
	  };

	  var builtinIteratee;

	  // An internal function to generate callbacks that can be applied to each
	  // element in a collection, returning the desired result — either `identity`,
	  // an arbitrary callback, a property matcher, or a property accessor.
	  var cb = function(value, context, argCount) {
	    if (_.iteratee !== builtinIteratee) return _.iteratee(value, context);
	    if (value == null) return _.identity;
	    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
	    if (_.isObject(value) && !_.isArray(value)) return _.matcher(value);
	    return _.property(value);
	  };

	  // External wrapper for our callback generator. Users may customize
	  // `_.iteratee` if they want additional predicate/iteratee shorthand styles.
	  // This abstraction hides the internal-only argCount argument.
	  _.iteratee = builtinIteratee = function(value, context) {
	    return cb(value, context, Infinity);
	  };

	  // Some functions take a variable number of arguments, or a few expected
	  // arguments at the beginning and then a variable number of values to operate
	  // on. This helper accumulates all remaining arguments past the function’s
	  // argument length (or an explicit `startIndex`), into an array that becomes
	  // the last argument. Similar to ES6’s "rest parameter".
	  var restArguments = function(func, startIndex) {
	    startIndex = startIndex == null ? func.length - 1 : +startIndex;
	    return function() {
	      var length = Math.max(arguments.length - startIndex, 0),
	          rest = Array(length),
	          index = 0;
	      for (; index < length; index++) {
	        rest[index] = arguments[index + startIndex];
	      }
	      switch (startIndex) {
	        case 0: return func.call(this, rest);
	        case 1: return func.call(this, arguments[0], rest);
	        case 2: return func.call(this, arguments[0], arguments[1], rest);
	      }
	      var args = Array(startIndex + 1);
	      for (index = 0; index < startIndex; index++) {
	        args[index] = arguments[index];
	      }
	      args[startIndex] = rest;
	      return func.apply(this, args);
	    };
	  };

	  // An internal function for creating a new object that inherits from another.
	  var baseCreate = function(prototype) {
	    if (!_.isObject(prototype)) return {};
	    if (nativeCreate) return nativeCreate(prototype);
	    Ctor.prototype = prototype;
	    var result = new Ctor;
	    Ctor.prototype = null;
	    return result;
	  };

	  var shallowProperty = function(key) {
	    return function(obj) {
	      return obj == null ? void 0 : obj[key];
	    };
	  };

	  var has = function(obj, path) {
	    return obj != null && hasOwnProperty.call(obj, path);
	  };

	  var deepGet = function(obj, path) {
	    var length = path.length;
	    for (var i = 0; i < length; i++) {
	      if (obj == null) return void 0;
	      obj = obj[path[i]];
	    }
	    return length ? obj : void 0;
	  };

	  // Helper for collection methods to determine whether a collection
	  // should be iterated as an array or as an object.
	  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
	  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
	  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
	  var getLength = shallowProperty('length');
	  var isArrayLike = function(collection) {
	    var length = getLength(collection);
	    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
	  };

	  // Collection Functions
	  // --------------------

	  // The cornerstone, an `each` implementation, aka `forEach`.
	  // Handles raw objects in addition to array-likes. Treats all
	  // sparse array-likes as if they were dense.
	  _.each = _.forEach = function(obj, iteratee, context) {
	    iteratee = optimizeCb(iteratee, context);
	    var i, length;
	    if (isArrayLike(obj)) {
	      for (i = 0, length = obj.length; i < length; i++) {
	        iteratee(obj[i], i, obj);
	      }
	    } else {
	      var keys = _.keys(obj);
	      for (i = 0, length = keys.length; i < length; i++) {
	        iteratee(obj[keys[i]], keys[i], obj);
	      }
	    }
	    return obj;
	  };

	  // Return the results of applying the iteratee to each element.
	  _.map = _.collect = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length,
	        results = Array(length);
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      results[index] = iteratee(obj[currentKey], currentKey, obj);
	    }
	    return results;
	  };

	  // Create a reducing function iterating left or right.
	  var createReduce = function(dir) {
	    // Wrap code that reassigns argument variables in a separate function than
	    // the one that accesses `arguments.length` to avoid a perf hit. (#1991)
	    var reducer = function(obj, iteratee, memo, initial) {
	      var keys = !isArrayLike(obj) && _.keys(obj),
	          length = (keys || obj).length,
	          index = dir > 0 ? 0 : length - 1;
	      if (!initial) {
	        memo = obj[keys ? keys[index] : index];
	        index += dir;
	      }
	      for (; index >= 0 && index < length; index += dir) {
	        var currentKey = keys ? keys[index] : index;
	        memo = iteratee(memo, obj[currentKey], currentKey, obj);
	      }
	      return memo;
	    };

	    return function(obj, iteratee, memo, context) {
	      var initial = arguments.length >= 3;
	      return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);
	    };
	  };

	  // **Reduce** builds up a single result from a list of values, aka `inject`,
	  // or `foldl`.
	  _.reduce = _.foldl = _.inject = createReduce(1);

	  // The right-associative version of reduce, also known as `foldr`.
	  _.reduceRight = _.foldr = createReduce(-1);

	  // Return the first value which passes a truth test. Aliased as `detect`.
	  _.find = _.detect = function(obj, predicate, context) {
	    var keyFinder = isArrayLike(obj) ? _.findIndex : _.findKey;
	    var key = keyFinder(obj, predicate, context);
	    if (key !== void 0 && key !== -1) return obj[key];
	  };

	  // Return all the elements that pass a truth test.
	  // Aliased as `select`.
	  _.filter = _.select = function(obj, predicate, context) {
	    var results = [];
	    predicate = cb(predicate, context);
	    _.each(obj, function(value, index, list) {
	      if (predicate(value, index, list)) results.push(value);
	    });
	    return results;
	  };

	  // Return all the elements for which a truth test fails.
	  _.reject = function(obj, predicate, context) {
	    return _.filter(obj, _.negate(cb(predicate)), context);
	  };

	  // Determine whether all of the elements match a truth test.
	  // Aliased as `all`.
	  _.every = _.all = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length;
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      if (!predicate(obj[currentKey], currentKey, obj)) return false;
	    }
	    return true;
	  };

	  // Determine if at least one element in the object matches a truth test.
	  // Aliased as `any`.
	  _.some = _.any = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length;
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      if (predicate(obj[currentKey], currentKey, obj)) return true;
	    }
	    return false;
	  };

	  // Determine if the array or object contains a given item (using `===`).
	  // Aliased as `includes` and `include`.
	  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
	    if (!isArrayLike(obj)) obj = _.values(obj);
	    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
	    return _.indexOf(obj, item, fromIndex) >= 0;
	  };

	  // Invoke a method (with arguments) on every item in a collection.
	  _.invoke = restArguments(function(obj, path, args) {
	    var contextPath, func;
	    if (_.isFunction(path)) {
	      func = path;
	    } else if (_.isArray(path)) {
	      contextPath = path.slice(0, -1);
	      path = path[path.length - 1];
	    }
	    return _.map(obj, function(context) {
	      var method = func;
	      if (!method) {
	        if (contextPath && contextPath.length) {
	          context = deepGet(context, contextPath);
	        }
	        if (context == null) return void 0;
	        method = context[path];
	      }
	      return method == null ? method : method.apply(context, args);
	    });
	  });

	  // Convenience version of a common use case of `map`: fetching a property.
	  _.pluck = function(obj, key) {
	    return _.map(obj, _.property(key));
	  };

	  // Convenience version of a common use case of `filter`: selecting only objects
	  // containing specific `key:value` pairs.
	  _.where = function(obj, attrs) {
	    return _.filter(obj, _.matcher(attrs));
	  };

	  // Convenience version of a common use case of `find`: getting the first object
	  // containing specific `key:value` pairs.
	  _.findWhere = function(obj, attrs) {
	    return _.find(obj, _.matcher(attrs));
	  };

	  // Return the maximum element (or element-based computation).
	  _.max = function(obj, iteratee, context) {
	    var result = -Infinity, lastComputed = -Infinity,
	        value, computed;
	    if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {
	      obj = isArrayLike(obj) ? obj : _.values(obj);
	      for (var i = 0, length = obj.length; i < length; i++) {
	        value = obj[i];
	        if (value != null && value > result) {
	          result = value;
	        }
	      }
	    } else {
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(v, index, list) {
	        computed = iteratee(v, index, list);
	        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
	          result = v;
	          lastComputed = computed;
	        }
	      });
	    }
	    return result;
	  };

	  // Return the minimum element (or element-based computation).
	  _.min = function(obj, iteratee, context) {
	    var result = Infinity, lastComputed = Infinity,
	        value, computed;
	    if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {
	      obj = isArrayLike(obj) ? obj : _.values(obj);
	      for (var i = 0, length = obj.length; i < length; i++) {
	        value = obj[i];
	        if (value != null && value < result) {
	          result = value;
	        }
	      }
	    } else {
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(v, index, list) {
	        computed = iteratee(v, index, list);
	        if (computed < lastComputed || computed === Infinity && result === Infinity) {
	          result = v;
	          lastComputed = computed;
	        }
	      });
	    }
	    return result;
	  };

	  // Shuffle a collection.
	  _.shuffle = function(obj) {
	    return _.sample(obj, Infinity);
	  };

	  // Sample **n** random values from a collection using the modern version of the
	  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
	  // If **n** is not specified, returns a single random element.
	  // The internal `guard` argument allows it to work with `map`.
	  _.sample = function(obj, n, guard) {
	    if (n == null || guard) {
	      if (!isArrayLike(obj)) obj = _.values(obj);
	      return obj[_.random(obj.length - 1)];
	    }
	    var sample = isArrayLike(obj) ? _.clone(obj) : _.values(obj);
	    var length = getLength(sample);
	    n = Math.max(Math.min(n, length), 0);
	    var last = length - 1;
	    for (var index = 0; index < n; index++) {
	      var rand = _.random(index, last);
	      var temp = sample[index];
	      sample[index] = sample[rand];
	      sample[rand] = temp;
	    }
	    return sample.slice(0, n);
	  };

	  // Sort the object's values by a criterion produced by an iteratee.
	  _.sortBy = function(obj, iteratee, context) {
	    var index = 0;
	    iteratee = cb(iteratee, context);
	    return _.pluck(_.map(obj, function(value, key, list) {
	      return {
	        value: value,
	        index: index++,
	        criteria: iteratee(value, key, list)
	      };
	    }).sort(function(left, right) {
	      var a = left.criteria;
	      var b = right.criteria;
	      if (a !== b) {
	        if (a > b || a === void 0) return 1;
	        if (a < b || b === void 0) return -1;
	      }
	      return left.index - right.index;
	    }), 'value');
	  };

	  // An internal function used for aggregate "group by" operations.
	  var group = function(behavior, partition) {
	    return function(obj, iteratee, context) {
	      var result = partition ? [[], []] : {};
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index) {
	        var key = iteratee(value, index, obj);
	        behavior(result, value, key);
	      });
	      return result;
	    };
	  };

	  // Groups the object's values by a criterion. Pass either a string attribute
	  // to group by, or a function that returns the criterion.
	  _.groupBy = group(function(result, value, key) {
	    if (has(result, key)) result[key].push(value); else result[key] = [value];
	  });

	  // Indexes the object's values by a criterion, similar to `groupBy`, but for
	  // when you know that your index values will be unique.
	  _.indexBy = group(function(result, value, key) {
	    result[key] = value;
	  });

	  // Counts instances of an object that group by a certain criterion. Pass
	  // either a string attribute to count by, or a function that returns the
	  // criterion.
	  _.countBy = group(function(result, value, key) {
	    if (has(result, key)) result[key]++; else result[key] = 1;
	  });

	  var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
	  // Safely create a real, live array from anything iterable.
	  _.toArray = function(obj) {
	    if (!obj) return [];
	    if (_.isArray(obj)) return slice.call(obj);
	    if (_.isString(obj)) {
	      // Keep surrogate pair characters together
	      return obj.match(reStrSymbol);
	    }
	    if (isArrayLike(obj)) return _.map(obj, _.identity);
	    return _.values(obj);
	  };

	  // Return the number of elements in an object.
	  _.size = function(obj) {
	    if (obj == null) return 0;
	    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
	  };

	  // Split a collection into two arrays: one whose elements all satisfy the given
	  // predicate, and one whose elements all do not satisfy the predicate.
	  _.partition = group(function(result, value, pass) {
	    result[pass ? 0 : 1].push(value);
	  }, true);

	  // Array Functions
	  // ---------------

	  // Get the first element of an array. Passing **n** will return the first N
	  // values in the array. Aliased as `head` and `take`. The **guard** check
	  // allows it to work with `_.map`.
	  _.first = _.head = _.take = function(array, n, guard) {
	    if (array == null || array.length < 1) return n == null ? void 0 : [];
	    if (n == null || guard) return array[0];
	    return _.initial(array, array.length - n);
	  };

	  // Returns everything but the last entry of the array. Especially useful on
	  // the arguments object. Passing **n** will return all the values in
	  // the array, excluding the last N.
	  _.initial = function(array, n, guard) {
	    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
	  };

	  // Get the last element of an array. Passing **n** will return the last N
	  // values in the array.
	  _.last = function(array, n, guard) {
	    if (array == null || array.length < 1) return n == null ? void 0 : [];
	    if (n == null || guard) return array[array.length - 1];
	    return _.rest(array, Math.max(0, array.length - n));
	  };

	  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
	  // Especially useful on the arguments object. Passing an **n** will return
	  // the rest N values in the array.
	  _.rest = _.tail = _.drop = function(array, n, guard) {
	    return slice.call(array, n == null || guard ? 1 : n);
	  };

	  // Trim out all falsy values from an array.
	  _.compact = function(array) {
	    return _.filter(array, Boolean);
	  };

	  // Internal implementation of a recursive `flatten` function.
	  var flatten = function(input, shallow, strict, output) {
	    output = output || [];
	    var idx = output.length;
	    for (var i = 0, length = getLength(input); i < length; i++) {
	      var value = input[i];
	      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
	        // Flatten current level of array or arguments object.
	        if (shallow) {
	          var j = 0, len = value.length;
	          while (j < len) output[idx++] = value[j++];
	        } else {
	          flatten(value, shallow, strict, output);
	          idx = output.length;
	        }
	      } else if (!strict) {
	        output[idx++] = value;
	      }
	    }
	    return output;
	  };

	  // Flatten out an array, either recursively (by default), or just one level.
	  _.flatten = function(array, shallow) {
	    return flatten(array, shallow, false);
	  };

	  // Return a version of the array that does not contain the specified value(s).
	  _.without = restArguments(function(array, otherArrays) {
	    return _.difference(array, otherArrays);
	  });

	  // Produce a duplicate-free version of the array. If the array has already
	  // been sorted, you have the option of using a faster algorithm.
	  // The faster algorithm will not work with an iteratee if the iteratee
	  // is not a one-to-one function, so providing an iteratee will disable
	  // the faster algorithm.
	  // Aliased as `unique`.
	  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
	    if (!_.isBoolean(isSorted)) {
	      context = iteratee;
	      iteratee = isSorted;
	      isSorted = false;
	    }
	    if (iteratee != null) iteratee = cb(iteratee, context);
	    var result = [];
	    var seen = [];
	    for (var i = 0, length = getLength(array); i < length; i++) {
	      var value = array[i],
	          computed = iteratee ? iteratee(value, i, array) : value;
	      if (isSorted && !iteratee) {
	        if (!i || seen !== computed) result.push(value);
	        seen = computed;
	      } else if (iteratee) {
	        if (!_.contains(seen, computed)) {
	          seen.push(computed);
	          result.push(value);
	        }
	      } else if (!_.contains(result, value)) {
	        result.push(value);
	      }
	    }
	    return result;
	  };

	  // Produce an array that contains the union: each distinct element from all of
	  // the passed-in arrays.
	  _.union = restArguments(function(arrays) {
	    return _.uniq(flatten(arrays, true, true));
	  });

	  // Produce an array that contains every item shared between all the
	  // passed-in arrays.
	  _.intersection = function(array) {
	    var result = [];
	    var argsLength = arguments.length;
	    for (var i = 0, length = getLength(array); i < length; i++) {
	      var item = array[i];
	      if (_.contains(result, item)) continue;
	      var j;
	      for (j = 1; j < argsLength; j++) {
	        if (!_.contains(arguments[j], item)) break;
	      }
	      if (j === argsLength) result.push(item);
	    }
	    return result;
	  };

	  // Take the difference between one array and a number of other arrays.
	  // Only the elements present in just the first array will remain.
	  _.difference = restArguments(function(array, rest) {
	    rest = flatten(rest, true, true);
	    return _.filter(array, function(value){
	      return !_.contains(rest, value);
	    });
	  });

	  // Complement of _.zip. Unzip accepts an array of arrays and groups
	  // each array's elements on shared indices.
	  _.unzip = function(array) {
	    var length = array && _.max(array, getLength).length || 0;
	    var result = Array(length);

	    for (var index = 0; index < length; index++) {
	      result[index] = _.pluck(array, index);
	    }
	    return result;
	  };

	  // Zip together multiple lists into a single array -- elements that share
	  // an index go together.
	  _.zip = restArguments(_.unzip);

	  // Converts lists into objects. Pass either a single array of `[key, value]`
	  // pairs, or two parallel arrays of the same length -- one of keys, and one of
	  // the corresponding values. Passing by pairs is the reverse of _.pairs.
	  _.object = function(list, values) {
	    var result = {};
	    for (var i = 0, length = getLength(list); i < length; i++) {
	      if (values) {
	        result[list[i]] = values[i];
	      } else {
	        result[list[i][0]] = list[i][1];
	      }
	    }
	    return result;
	  };

	  // Generator function to create the findIndex and findLastIndex functions.
	  var createPredicateIndexFinder = function(dir) {
	    return function(array, predicate, context) {
	      predicate = cb(predicate, context);
	      var length = getLength(array);
	      var index = dir > 0 ? 0 : length - 1;
	      for (; index >= 0 && index < length; index += dir) {
	        if (predicate(array[index], index, array)) return index;
	      }
	      return -1;
	    };
	  };

	  // Returns the first index on an array-like that passes a predicate test.
	  _.findIndex = createPredicateIndexFinder(1);
	  _.findLastIndex = createPredicateIndexFinder(-1);

	  // Use a comparator function to figure out the smallest index at which
	  // an object should be inserted so as to maintain order. Uses binary search.
	  _.sortedIndex = function(array, obj, iteratee, context) {
	    iteratee = cb(iteratee, context, 1);
	    var value = iteratee(obj);
	    var low = 0, high = getLength(array);
	    while (low < high) {
	      var mid = Math.floor((low + high) / 2);
	      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
	    }
	    return low;
	  };

	  // Generator function to create the indexOf and lastIndexOf functions.
	  var createIndexFinder = function(dir, predicateFind, sortedIndex) {
	    return function(array, item, idx) {
	      var i = 0, length = getLength(array);
	      if (typeof idx == 'number') {
	        if (dir > 0) {
	          i = idx >= 0 ? idx : Math.max(idx + length, i);
	        } else {
	          length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
	        }
	      } else if (sortedIndex && idx && length) {
	        idx = sortedIndex(array, item);
	        return array[idx] === item ? idx : -1;
	      }
	      if (item !== item) {
	        idx = predicateFind(slice.call(array, i, length), _.isNaN);
	        return idx >= 0 ? idx + i : -1;
	      }
	      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
	        if (array[idx] === item) return idx;
	      }
	      return -1;
	    };
	  };

	  // Return the position of the first occurrence of an item in an array,
	  // or -1 if the item is not included in the array.
	  // If the array is large and already in sort order, pass `true`
	  // for **isSorted** to use binary search.
	  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
	  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

	  // Generate an integer Array containing an arithmetic progression. A port of
	  // the native Python `range()` function. See
	  // [the Python documentation](http://docs.python.org/library/functions.html#range).
	  _.range = function(start, stop, step) {
	    if (stop == null) {
	      stop = start || 0;
	      start = 0;
	    }
	    if (!step) {
	      step = stop < start ? -1 : 1;
	    }

	    var length = Math.max(Math.ceil((stop - start) / step), 0);
	    var range = Array(length);

	    for (var idx = 0; idx < length; idx++, start += step) {
	      range[idx] = start;
	    }

	    return range;
	  };

	  // Chunk a single array into multiple arrays, each containing `count` or fewer
	  // items.
	  _.chunk = function(array, count) {
	    if (count == null || count < 1) return [];
	    var result = [];
	    var i = 0, length = array.length;
	    while (i < length) {
	      result.push(slice.call(array, i, i += count));
	    }
	    return result;
	  };

	  // Function (ahem) Functions
	  // ------------------

	  // Determines whether to execute a function as a constructor
	  // or a normal function with the provided arguments.
	  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
	    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
	    var self = baseCreate(sourceFunc.prototype);
	    var result = sourceFunc.apply(self, args);
	    if (_.isObject(result)) return result;
	    return self;
	  };

	  // Create a function bound to a given object (assigning `this`, and arguments,
	  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
	  // available.
	  _.bind = restArguments(function(func, context, args) {
	    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
	    var bound = restArguments(function(callArgs) {
	      return executeBound(func, bound, context, this, args.concat(callArgs));
	    });
	    return bound;
	  });

	  // Partially apply a function by creating a version that has had some of its
	  // arguments pre-filled, without changing its dynamic `this` context. _ acts
	  // as a placeholder by default, allowing any combination of arguments to be
	  // pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.
	  _.partial = restArguments(function(func, boundArgs) {
	    var placeholder = _.partial.placeholder;
	    var bound = function() {
	      var position = 0, length = boundArgs.length;
	      var args = Array(length);
	      for (var i = 0; i < length; i++) {
	        args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
	      }
	      while (position < arguments.length) args.push(arguments[position++]);
	      return executeBound(func, bound, this, this, args);
	    };
	    return bound;
	  });

	  _.partial.placeholder = _;

	  // Bind a number of an object's methods to that object. Remaining arguments
	  // are the method names to be bound. Useful for ensuring that all callbacks
	  // defined on an object belong to it.
	  _.bindAll = restArguments(function(obj, keys) {
	    keys = flatten(keys, false, false);
	    var index = keys.length;
	    if (index < 1) throw new Error('bindAll must be passed function names');
	    while (index--) {
	      var key = keys[index];
	      obj[key] = _.bind(obj[key], obj);
	    }
	  });

	  // Memoize an expensive function by storing its results.
	  _.memoize = function(func, hasher) {
	    var memoize = function(key) {
	      var cache = memoize.cache;
	      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
	      if (!has(cache, address)) cache[address] = func.apply(this, arguments);
	      return cache[address];
	    };
	    memoize.cache = {};
	    return memoize;
	  };

	  // Delays a function for the given number of milliseconds, and then calls
	  // it with the arguments supplied.
	  _.delay = restArguments(function(func, wait, args) {
	    return setTimeout(function() {
	      return func.apply(null, args);
	    }, wait);
	  });

	  // Defers a function, scheduling it to run after the current call stack has
	  // cleared.
	  _.defer = _.partial(_.delay, _, 1);

	  // Returns a function, that, when invoked, will only be triggered at most once
	  // during a given window of time. Normally, the throttled function will run
	  // as much as it can, without ever going more than once per `wait` duration;
	  // but if you'd like to disable the execution on the leading edge, pass
	  // `{leading: false}`. To disable execution on the trailing edge, ditto.
	  _.throttle = function(func, wait, options) {
	    var timeout, context, args, result;
	    var previous = 0;
	    if (!options) options = {};

	    var later = function() {
	      previous = options.leading === false ? 0 : _.now();
	      timeout = null;
	      result = func.apply(context, args);
	      if (!timeout) context = args = null;
	    };

	    var throttled = function() {
	      var now = _.now();
	      if (!previous && options.leading === false) previous = now;
	      var remaining = wait - (now - previous);
	      context = this;
	      args = arguments;
	      if (remaining <= 0 || remaining > wait) {
	        if (timeout) {
	          clearTimeout(timeout);
	          timeout = null;
	        }
	        previous = now;
	        result = func.apply(context, args);
	        if (!timeout) context = args = null;
	      } else if (!timeout && options.trailing !== false) {
	        timeout = setTimeout(later, remaining);
	      }
	      return result;
	    };

	    throttled.cancel = function() {
	      clearTimeout(timeout);
	      previous = 0;
	      timeout = context = args = null;
	    };

	    return throttled;
	  };

	  // Returns a function, that, as long as it continues to be invoked, will not
	  // be triggered. The function will be called after it stops being called for
	  // N milliseconds. If `immediate` is passed, trigger the function on the
	  // leading edge, instead of the trailing.
	  _.debounce = function(func, wait, immediate) {
	    var timeout, result;

	    var later = function(context, args) {
	      timeout = null;
	      if (args) result = func.apply(context, args);
	    };

	    var debounced = restArguments(function(args) {
	      if (timeout) clearTimeout(timeout);
	      if (immediate) {
	        var callNow = !timeout;
	        timeout = setTimeout(later, wait);
	        if (callNow) result = func.apply(this, args);
	      } else {
	        timeout = _.delay(later, wait, this, args);
	      }

	      return result;
	    });

	    debounced.cancel = function() {
	      clearTimeout(timeout);
	      timeout = null;
	    };

	    return debounced;
	  };

	  // Returns the first function passed as an argument to the second,
	  // allowing you to adjust arguments, run code before and after, and
	  // conditionally execute the original function.
	  _.wrap = function(func, wrapper) {
	    return _.partial(wrapper, func);
	  };

	  // Returns a negated version of the passed-in predicate.
	  _.negate = function(predicate) {
	    return function() {
	      return !predicate.apply(this, arguments);
	    };
	  };

	  // Returns a function that is the composition of a list of functions, each
	  // consuming the return value of the function that follows.
	  _.compose = function() {
	    var args = arguments;
	    var start = args.length - 1;
	    return function() {
	      var i = start;
	      var result = args[start].apply(this, arguments);
	      while (i--) result = args[i].call(this, result);
	      return result;
	    };
	  };

	  // Returns a function that will only be executed on and after the Nth call.
	  _.after = function(times, func) {
	    return function() {
	      if (--times < 1) {
	        return func.apply(this, arguments);
	      }
	    };
	  };

	  // Returns a function that will only be executed up to (but not including) the Nth call.
	  _.before = function(times, func) {
	    var memo;
	    return function() {
	      if (--times > 0) {
	        memo = func.apply(this, arguments);
	      }
	      if (times <= 1) func = null;
	      return memo;
	    };
	  };

	  // Returns a function that will be executed at most one time, no matter how
	  // often you call it. Useful for lazy initialization.
	  _.once = _.partial(_.before, 2);

	  _.restArguments = restArguments;

	  // Object Functions
	  // ----------------

	  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
	  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
	  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
	    'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

	  var collectNonEnumProps = function(obj, keys) {
	    var nonEnumIdx = nonEnumerableProps.length;
	    var constructor = obj.constructor;
	    var proto = _.isFunction(constructor) && constructor.prototype || ObjProto;

	    // Constructor is a special case.
	    var prop = 'constructor';
	    if (has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

	    while (nonEnumIdx--) {
	      prop = nonEnumerableProps[nonEnumIdx];
	      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
	        keys.push(prop);
	      }
	    }
	  };

	  // Retrieve the names of an object's own properties.
	  // Delegates to **ECMAScript 5**'s native `Object.keys`.
	  _.keys = function(obj) {
	    if (!_.isObject(obj)) return [];
	    if (nativeKeys) return nativeKeys(obj);
	    var keys = [];
	    for (var key in obj) if (has(obj, key)) keys.push(key);
	    // Ahem, IE < 9.
	    if (hasEnumBug) collectNonEnumProps(obj, keys);
	    return keys;
	  };

	  // Retrieve all the property names of an object.
	  _.allKeys = function(obj) {
	    if (!_.isObject(obj)) return [];
	    var keys = [];
	    for (var key in obj) keys.push(key);
	    // Ahem, IE < 9.
	    if (hasEnumBug) collectNonEnumProps(obj, keys);
	    return keys;
	  };

	  // Retrieve the values of an object's properties.
	  _.values = function(obj) {
	    var keys = _.keys(obj);
	    var length = keys.length;
	    var values = Array(length);
	    for (var i = 0; i < length; i++) {
	      values[i] = obj[keys[i]];
	    }
	    return values;
	  };

	  // Returns the results of applying the iteratee to each element of the object.
	  // In contrast to _.map it returns an object.
	  _.mapObject = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    var keys = _.keys(obj),
	        length = keys.length,
	        results = {};
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys[index];
	      results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
	    }
	    return results;
	  };

	  // Convert an object into a list of `[key, value]` pairs.
	  // The opposite of _.object.
	  _.pairs = function(obj) {
	    var keys = _.keys(obj);
	    var length = keys.length;
	    var pairs = Array(length);
	    for (var i = 0; i < length; i++) {
	      pairs[i] = [keys[i], obj[keys[i]]];
	    }
	    return pairs;
	  };

	  // Invert the keys and values of an object. The values must be serializable.
	  _.invert = function(obj) {
	    var result = {};
	    var keys = _.keys(obj);
	    for (var i = 0, length = keys.length; i < length; i++) {
	      result[obj[keys[i]]] = keys[i];
	    }
	    return result;
	  };

	  // Return a sorted list of the function names available on the object.
	  // Aliased as `methods`.
	  _.functions = _.methods = function(obj) {
	    var names = [];
	    for (var key in obj) {
	      if (_.isFunction(obj[key])) names.push(key);
	    }
	    return names.sort();
	  };

	  // An internal function for creating assigner functions.
	  var createAssigner = function(keysFunc, defaults) {
	    return function(obj) {
	      var length = arguments.length;
	      if (defaults) obj = Object(obj);
	      if (length < 2 || obj == null) return obj;
	      for (var index = 1; index < length; index++) {
	        var source = arguments[index],
	            keys = keysFunc(source),
	            l = keys.length;
	        for (var i = 0; i < l; i++) {
	          var key = keys[i];
	          if (!defaults || obj[key] === void 0) obj[key] = source[key];
	        }
	      }
	      return obj;
	    };
	  };

	  // Extend a given object with all the properties in passed-in object(s).
	  _.extend = createAssigner(_.allKeys);

	  // Assigns a given object with all the own properties in the passed-in object(s).
	  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
	  _.extendOwn = _.assign = createAssigner(_.keys);

	  // Returns the first key on an object that passes a predicate test.
	  _.findKey = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = _.keys(obj), key;
	    for (var i = 0, length = keys.length; i < length; i++) {
	      key = keys[i];
	      if (predicate(obj[key], key, obj)) return key;
	    }
	  };

	  // Internal pick helper function to determine if `obj` has key `key`.
	  var keyInObj = function(value, key, obj) {
	    return key in obj;
	  };

	  // Return a copy of the object only containing the whitelisted properties.
	  _.pick = restArguments(function(obj, keys) {
	    var result = {}, iteratee = keys[0];
	    if (obj == null) return result;
	    if (_.isFunction(iteratee)) {
	      if (keys.length > 1) iteratee = optimizeCb(iteratee, keys[1]);
	      keys = _.allKeys(obj);
	    } else {
	      iteratee = keyInObj;
	      keys = flatten(keys, false, false);
	      obj = Object(obj);
	    }
	    for (var i = 0, length = keys.length; i < length; i++) {
	      var key = keys[i];
	      var value = obj[key];
	      if (iteratee(value, key, obj)) result[key] = value;
	    }
	    return result;
	  });

	  // Return a copy of the object without the blacklisted properties.
	  _.omit = restArguments(function(obj, keys) {
	    var iteratee = keys[0], context;
	    if (_.isFunction(iteratee)) {
	      iteratee = _.negate(iteratee);
	      if (keys.length > 1) context = keys[1];
	    } else {
	      keys = _.map(flatten(keys, false, false), String);
	      iteratee = function(value, key) {
	        return !_.contains(keys, key);
	      };
	    }
	    return _.pick(obj, iteratee, context);
	  });

	  // Fill in a given object with default properties.
	  _.defaults = createAssigner(_.allKeys, true);

	  // Creates an object that inherits from the given prototype object.
	  // If additional properties are provided then they will be added to the
	  // created object.
	  _.create = function(prototype, props) {
	    var result = baseCreate(prototype);
	    if (props) _.extendOwn(result, props);
	    return result;
	  };

	  // Create a (shallow-cloned) duplicate of an object.
	  _.clone = function(obj) {
	    if (!_.isObject(obj)) return obj;
	    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
	  };

	  // Invokes interceptor with the obj, and then returns obj.
	  // The primary purpose of this method is to "tap into" a method chain, in
	  // order to perform operations on intermediate results within the chain.
	  _.tap = function(obj, interceptor) {
	    interceptor(obj);
	    return obj;
	  };

	  // Returns whether an object has a given set of `key:value` pairs.
	  _.isMatch = function(object, attrs) {
	    var keys = _.keys(attrs), length = keys.length;
	    if (object == null) return !length;
	    var obj = Object(object);
	    for (var i = 0; i < length; i++) {
	      var key = keys[i];
	      if (attrs[key] !== obj[key] || !(key in obj)) return false;
	    }
	    return true;
	  };


	  // Internal recursive comparison function for `isEqual`.
	  var eq, deepEq;
	  eq = function(a, b, aStack, bStack) {
	    // Identical objects are equal. `0 === -0`, but they aren't identical.
	    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
	    if (a === b) return a !== 0 || 1 / a === 1 / b;
	    // `null` or `undefined` only equal to itself (strict comparison).
	    if (a == null || b == null) return false;
	    // `NaN`s are equivalent, but non-reflexive.
	    if (a !== a) return b !== b;
	    // Exhaust primitive checks
	    var type = typeof a;
	    if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;
	    return deepEq(a, b, aStack, bStack);
	  };

	  // Internal recursive comparison function for `isEqual`.
	  deepEq = function(a, b, aStack, bStack) {
	    // Unwrap any wrapped objects.
	    if (a instanceof _) a = a._wrapped;
	    if (b instanceof _) b = b._wrapped;
	    // Compare `[[Class]]` names.
	    var className = toString.call(a);
	    if (className !== toString.call(b)) return false;
	    switch (className) {
	      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
	      case '[object RegExp]':
	      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
	      case '[object String]':
	        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
	        // equivalent to `new String("5")`.
	        return '' + a === '' + b;
	      case '[object Number]':
	        // `NaN`s are equivalent, but non-reflexive.
	        // Object(NaN) is equivalent to NaN.
	        if (+a !== +a) return +b !== +b;
	        // An `egal` comparison is performed for other numeric values.
	        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
	      case '[object Date]':
	      case '[object Boolean]':
	        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
	        // millisecond representations. Note that invalid dates with millisecond representations
	        // of `NaN` are not equivalent.
	        return +a === +b;
	      case '[object Symbol]':
	        return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
	    }

	    var areArrays = className === '[object Array]';
	    if (!areArrays) {
	      if (typeof a != 'object' || typeof b != 'object') return false;

	      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
	      // from different frames are.
	      var aCtor = a.constructor, bCtor = b.constructor;
	      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
	                               _.isFunction(bCtor) && bCtor instanceof bCtor)
	                          && ('constructor' in a && 'constructor' in b)) {
	        return false;
	      }
	    }
	    // Assume equality for cyclic structures. The algorithm for detecting cyclic
	    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

	    // Initializing stack of traversed objects.
	    // It's done here since we only need them for objects and arrays comparison.
	    aStack = aStack || [];
	    bStack = bStack || [];
	    var length = aStack.length;
	    while (length--) {
	      // Linear search. Performance is inversely proportional to the number of
	      // unique nested structures.
	      if (aStack[length] === a) return bStack[length] === b;
	    }

	    // Add the first object to the stack of traversed objects.
	    aStack.push(a);
	    bStack.push(b);

	    // Recursively compare objects and arrays.
	    if (areArrays) {
	      // Compare array lengths to determine if a deep comparison is necessary.
	      length = a.length;
	      if (length !== b.length) return false;
	      // Deep compare the contents, ignoring non-numeric properties.
	      while (length--) {
	        if (!eq(a[length], b[length], aStack, bStack)) return false;
	      }
	    } else {
	      // Deep compare objects.
	      var keys = _.keys(a), key;
	      length = keys.length;
	      // Ensure that both objects contain the same number of properties before comparing deep equality.
	      if (_.keys(b).length !== length) return false;
	      while (length--) {
	        // Deep compare each member
	        key = keys[length];
	        if (!(has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
	      }
	    }
	    // Remove the first object from the stack of traversed objects.
	    aStack.pop();
	    bStack.pop();
	    return true;
	  };

	  // Perform a deep comparison to check if two objects are equal.
	  _.isEqual = function(a, b) {
	    return eq(a, b);
	  };

	  // Is a given array, string, or object empty?
	  // An "empty" object has no enumerable own-properties.
	  _.isEmpty = function(obj) {
	    if (obj == null) return true;
	    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
	    return _.keys(obj).length === 0;
	  };

	  // Is a given value a DOM element?
	  _.isElement = function(obj) {
	    return !!(obj && obj.nodeType === 1);
	  };

	  // Is a given value an array?
	  // Delegates to ECMA5's native Array.isArray
	  _.isArray = nativeIsArray || function(obj) {
	    return toString.call(obj) === '[object Array]';
	  };

	  // Is a given variable an object?
	  _.isObject = function(obj) {
	    var type = typeof obj;
	    return type === 'function' || type === 'object' && !!obj;
	  };

	  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError, isMap, isWeakMap, isSet, isWeakSet.
	  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error', 'Symbol', 'Map', 'WeakMap', 'Set', 'WeakSet'], function(name) {
	    _['is' + name] = function(obj) {
	      return toString.call(obj) === '[object ' + name + ']';
	    };
	  });

	  // Define a fallback version of the method in browsers (ahem, IE < 9), where
	  // there isn't any inspectable "Arguments" type.
	  if (!_.isArguments(arguments)) {
	    _.isArguments = function(obj) {
	      return has(obj, 'callee');
	    };
	  }

	  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
	  // IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).
	  var nodelist = root.document && root.document.childNodes;
	  if (typeof Int8Array != 'object' && typeof nodelist != 'function') {
	    _.isFunction = function(obj) {
	      return typeof obj == 'function' || false;
	    };
	  }

	  // Is a given object a finite number?
	  _.isFinite = function(obj) {
	    return !_.isSymbol(obj) && isFinite(obj) && !isNaN(parseFloat(obj));
	  };

	  // Is the given value `NaN`?
	  _.isNaN = function(obj) {
	    return _.isNumber(obj) && isNaN(obj);
	  };

	  // Is a given value a boolean?
	  _.isBoolean = function(obj) {
	    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
	  };

	  // Is a given value equal to null?
	  _.isNull = function(obj) {
	    return obj === null;
	  };

	  // Is a given variable undefined?
	  _.isUndefined = function(obj) {
	    return obj === void 0;
	  };

	  // Shortcut function for checking if an object has a given property directly
	  // on itself (in other words, not on a prototype).
	  _.has = function(obj, path) {
	    if (!_.isArray(path)) {
	      return has(obj, path);
	    }
	    var length = path.length;
	    for (var i = 0; i < length; i++) {
	      var key = path[i];
	      if (obj == null || !hasOwnProperty.call(obj, key)) {
	        return false;
	      }
	      obj = obj[key];
	    }
	    return !!length;
	  };

	  // Utility Functions
	  // -----------------

	  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
	  // previous owner. Returns a reference to the Underscore object.
	  _.noConflict = function() {
	    root._ = previousUnderscore;
	    return this;
	  };

	  // Keep the identity function around for default iteratees.
	  _.identity = function(value) {
	    return value;
	  };

	  // Predicate-generating functions. Often useful outside of Underscore.
	  _.constant = function(value) {
	    return function() {
	      return value;
	    };
	  };

	  _.noop = function(){};

	  // Creates a function that, when passed an object, will traverse that object’s
	  // properties down the given `path`, specified as an array of keys or indexes.
	  _.property = function(path) {
	    if (!_.isArray(path)) {
	      return shallowProperty(path);
	    }
	    return function(obj) {
	      return deepGet(obj, path);
	    };
	  };

	  // Generates a function for a given object that returns a given property.
	  _.propertyOf = function(obj) {
	    if (obj == null) {
	      return function(){};
	    }
	    return function(path) {
	      return !_.isArray(path) ? obj[path] : deepGet(obj, path);
	    };
	  };

	  // Returns a predicate for checking whether an object has a given set of
	  // `key:value` pairs.
	  _.matcher = _.matches = function(attrs) {
	    attrs = _.extendOwn({}, attrs);
	    return function(obj) {
	      return _.isMatch(obj, attrs);
	    };
	  };

	  // Run a function **n** times.
	  _.times = function(n, iteratee, context) {
	    var accum = Array(Math.max(0, n));
	    iteratee = optimizeCb(iteratee, context, 1);
	    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
	    return accum;
	  };

	  // Return a random integer between min and max (inclusive).
	  _.random = function(min, max) {
	    if (max == null) {
	      max = min;
	      min = 0;
	    }
	    return min + Math.floor(Math.random() * (max - min + 1));
	  };

	  // A (possibly faster) way to get the current timestamp as an integer.
	  _.now = Date.now || function() {
	    return new Date().getTime();
	  };

	  // List of HTML entities for escaping.
	  var escapeMap = {
	    '&': '&amp;',
	    '<': '&lt;',
	    '>': '&gt;',
	    '"': '&quot;',
	    "'": '&#x27;',
	    '`': '&#x60;'
	  };
	  var unescapeMap = _.invert(escapeMap);

	  // Functions for escaping and unescaping strings to/from HTML interpolation.
	  var createEscaper = function(map) {
	    var escaper = function(match) {
	      return map[match];
	    };
	    // Regexes for identifying a key that needs to be escaped.
	    var source = '(?:' + _.keys(map).join('|') + ')';
	    var testRegexp = RegExp(source);
	    var replaceRegexp = RegExp(source, 'g');
	    return function(string) {
	      string = string == null ? '' : '' + string;
	      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
	    };
	  };
	  _.escape = createEscaper(escapeMap);
	  _.unescape = createEscaper(unescapeMap);

	  // Traverses the children of `obj` along `path`. If a child is a function, it
	  // is invoked with its parent as context. Returns the value of the final
	  // child, or `fallback` if any child is undefined.
	  _.result = function(obj, path, fallback) {
	    if (!_.isArray(path)) path = [path];
	    var length = path.length;
	    if (!length) {
	      return _.isFunction(fallback) ? fallback.call(obj) : fallback;
	    }
	    for (var i = 0; i < length; i++) {
	      var prop = obj == null ? void 0 : obj[path[i]];
	      if (prop === void 0) {
	        prop = fallback;
	        i = length; // Ensure we don't continue iterating.
	      }
	      obj = _.isFunction(prop) ? prop.call(obj) : prop;
	    }
	    return obj;
	  };

	  // Generate a unique integer id (unique within the entire client session).
	  // Useful for temporary DOM ids.
	  var idCounter = 0;
	  _.uniqueId = function(prefix) {
	    var id = ++idCounter + '';
	    return prefix ? prefix + id : id;
	  };

	  // By default, Underscore uses ERB-style template delimiters, change the
	  // following template settings to use alternative delimiters.
	  _.templateSettings = {
	    evaluate: /<%([\s\S]+?)%>/g,
	    interpolate: /<%=([\s\S]+?)%>/g,
	    escape: /<%-([\s\S]+?)%>/g
	  };

	  // When customizing `templateSettings`, if you don't want to define an
	  // interpolation, evaluation or escaping regex, we need one that is
	  // guaranteed not to match.
	  var noMatch = /(.)^/;

	  // Certain characters need to be escaped so that they can be put into a
	  // string literal.
	  var escapes = {
	    "'": "'",
	    '\\': '\\',
	    '\r': 'r',
	    '\n': 'n',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	  };

	  var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;

	  var escapeChar = function(match) {
	    return '\\' + escapes[match];
	  };

	  // JavaScript micro-templating, similar to John Resig's implementation.
	  // Underscore templating handles arbitrary delimiters, preserves whitespace,
	  // and correctly escapes quotes within interpolated code.
	  // NB: `oldSettings` only exists for backwards compatibility.
	  _.template = function(text, settings, oldSettings) {
	    if (!settings && oldSettings) settings = oldSettings;
	    settings = _.defaults({}, settings, _.templateSettings);

	    // Combine delimiters into one regular expression via alternation.
	    var matcher = RegExp([
	      (settings.escape || noMatch).source,
	      (settings.interpolate || noMatch).source,
	      (settings.evaluate || noMatch).source
	    ].join('|') + '|$', 'g');

	    // Compile the template source, escaping string literals appropriately.
	    var index = 0;
	    var source = "__p+='";
	    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
	      source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
	      index = offset + match.length;

	      if (escape) {
	        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
	      } else if (interpolate) {
	        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
	      } else if (evaluate) {
	        source += "';\n" + evaluate + "\n__p+='";
	      }

	      // Adobe VMs need the match returned to produce the correct offset.
	      return match;
	    });
	    source += "';\n";

	    // If a variable is not specified, place data values in local scope.
	    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

	    source = "var __t,__p='',__j=Array.prototype.join," +
	      "print=function(){__p+=__j.call(arguments,'');};\n" +
	      source + 'return __p;\n';

	    var render;
	    try {
	      render = new Function(settings.variable || 'obj', '_', source);
	    } catch (e) {
	      e.source = source;
	      throw e;
	    }

	    var template = function(data) {
	      return render.call(this, data, _);
	    };

	    // Provide the compiled source as a convenience for precompilation.
	    var argument = settings.variable || 'obj';
	    template.source = 'function(' + argument + '){\n' + source + '}';

	    return template;
	  };

	  // Add a "chain" function. Start chaining a wrapped Underscore object.
	  _.chain = function(obj) {
	    var instance = _(obj);
	    instance._chain = true;
	    return instance;
	  };

	  // OOP
	  // ---------------
	  // If Underscore is called as a function, it returns a wrapped object that
	  // can be used OO-style. This wrapper holds altered versions of all the
	  // underscore functions. Wrapped objects may be chained.

	  // Helper function to continue chaining intermediate results.
	  var chainResult = function(instance, obj) {
	    return instance._chain ? _(obj).chain() : obj;
	  };

	  // Add your own custom functions to the Underscore object.
	  _.mixin = function(obj) {
	    _.each(_.functions(obj), function(name) {
	      var func = _[name] = obj[name];
	      _.prototype[name] = function() {
	        var args = [this._wrapped];
	        push.apply(args, arguments);
	        return chainResult(this, func.apply(_, args));
	      };
	    });
	    return _;
	  };

	  // Add all of the Underscore functions to the wrapper object.
	  _.mixin(_);

	  // Add all mutator Array functions to the wrapper.
	  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      var obj = this._wrapped;
	      method.apply(obj, arguments);
	      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
	      return chainResult(this, obj);
	    };
	  });

	  // Add all accessor Array functions to the wrapper.
	  _.each(['concat', 'join', 'slice'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      return chainResult(this, method.apply(this._wrapped, arguments));
	    };
	  });

	  // Extracts the result from a wrapped and chained object.
	  _.prototype.value = function() {
	    return this._wrapped;
	  };

	  // Provide unwrapping proxy for some methods used in engine operations
	  // such as arithmetic and JSON stringification.
	  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

	  _.prototype.toString = function() {
	    return String(this._wrapped);
	  };
	}());
	});
	var underscore_1 = underscore._;

	// https://gist.github.com/bmershon/25a74f7b1c7cbd07e7456af1d2c07da1

	/**
	 * This function create the pairs between node and its links.
	 *
	 * @param links
	 * @returns [["nodeX,nodeY", Array(numberOfLinksRelatedToTheNodes)]]
	 */
	function pairNodeLinks(links) {
	    let nestedByNodes = {};
	    links.forEach(l => {
	        let sourceKey = l.source.join(',');
	        if (!nestedByNodes[sourceKey]) {
	            nestedByNodes[sourceKey] = [];
	        }
	        nestedByNodes[sourceKey].push(l);
	        let targetKey = l.target.join(',');
	        if (!nestedByNodes[targetKey]) {
	            nestedByNodes[targetKey] = [];
	        }
	        nestedByNodes[targetKey].push(l);
	    });
	    //Pair the results
	    let pairedResults = underscore.pairs(nestedByNodes);
	    return pairedResults;
	}

	/**
	 * This function returns corners (three vertices) of vertices of degree two in the for mat of
	 * point1, point2, point3 => point1 is the the vertex with degree two (two edges connected to it are [point1, point2] and [point1, point3] (order of the points in each edge is not important)).
	 * @param tree
	 * @returns {*}
	 */
	function getAllV2CornersFromTree(tree) {
	    let pairedResults = pairNodeLinks(tree.links);
	    //Get all pairs with length = 2 (V2)
	    let allV2 = pairedResults.filter(p => p[1].length == 2);

	    let allCorners = allV2.map(v2 => {
	        let corner = [];
	        //First point is the common vertice
	        corner.push(v2[0].split(',').map(d => +d));//map(d=>+d) is to convert the strings into digits
	        //Push the source or target if they are not the common vertices of the two edges
	        v2[1].forEach(link => {
	            if (link.source.join(',') != v2[0]) {
	                corner.push(link.source);
	            } else {
	                corner.push(link.target);
	            }
	        });
	        return corner;
	    });
	    return allCorners;
	}

	/**
	 * This function returns all single degree vertices from a tree
	 * @param tree
	 */
	function getAllV1sFromTree(tree){
	    let pairedResults = pairNodeLinks(tree.links);
	    //Get all pairs with length = 2 (V2)
	    let allV1 = pairedResults.filter(p => p[1].length == 1);
	    return allV1.map(v1=>v1[0].split(',').map(Number));
	}
	/**
	 * Create a graph from mesh
	 * @param triangles is inform of set of triangles as the result from delaunay triangulations
	 */
	function createGraph (triangles) {

	    function makeLink(sourceId, targetId, weight) {
	        return {"source": sourceId, "target": targetId, "weight": weight};
	    }

	    let graph = {};
	    graph.nodes = [];
	    graph.links = [];
	    //Creating nodes
	    triangles.forEach(t => {
	        for (let i = 0; i < 3; i++) {
	            let id = t[i];
	            if (!idExists(graph.nodes, id)) {
	                graph.nodes.push(makeNode(id));
	            }
	        }
	    });

	    //Creating links
	    triangles.forEach(t => {
	        for (let i = 0; i < 3; i++) {
	            let p1 = t[i];
	            let p2 = t[(i + 1) % 3];
	            let id1 = p1;
	            let id2 = p2;
	            let dist = distance(p1, p2);
	            let link = makeLink(id1, id2, dist);
	            if (!linkExists(graph.links, link)) {
	                graph.links.push(link);
	            }
	        }
	    });


	    //TODO: may sort the id alphabetically => when creating => so we can just check 1 condition only.
	    function linkExists(links, link) {
	        let length = links.length;
	        for (let i = length-1; i >= 0; --i) {
	            if (equalLinks(link, links[i])) {
	                return true;
	            }
	        }
	        return false;
	    }

	    return graph;
	}

	function distance(a, b) {
	    let dx = a[0] - b[0],
	        dy = a[1] - b[1];
	    //For computer storage issue, some coordinates of the same distance may return different distances if we use long floating point
	    //So take only 10 digits after the floating points=> this is precise enough and still have the same values for two different lines of the same distance
	    return Math.round(Math.sqrt((dx * dx) + (dy * dy))*Math.pow(10, 10))/Math.pow(10, 10);
	}

	function equalPoints(id1, id2) {
	    return (id1[0] === id2[0] && id1[1] === id2[1]);
	}
	function equalLinks(l1, l2) {
	    return (equalPoints(l1.source, l2.source) && equalPoints(l1.target, l2.target)) ||
	        (equalPoints(l1.source, l2.target) && equalPoints(l1.target, l2.source));
	}
	function idExists(nodes, id) {
	    let length = nodes.length;
	    for (let i = length-1; i >= 0; --i) {
	        let node = nodes[i];
	        if (equalPoints(node.id, id)) {
	            return true;
	        }
	    }
	    return false;
	}
	function makeNode(id) {
	    return {"id": id};
	}
	/**
	 * create the mst
	 * @param graph: in form of nodes and links
	 * @returns {{nodes: (selection_nodes|nodes), links: Array}}
	 */
	function mst (graph) {
	    let vertices = graph.nodes,
	        edges = graph.links.slice(0),
	        selectedEdges = [],
	        forest = new DisjointSet();

	    // Each vertex begins "disconnected" and isolated from all the others.
	    vertices.forEach((vertex) => {
	        forest.makeSet(vertex.id);
	    });

	    // Sort edges in descending order of weight. We will pop edges beginning
	    // from the end of the array.
	    edges.sort((a, b) => {
	        return -(a.weight - b.weight);
	    });

	    while (edges.length && forest.size() > 1) {
	        let edge = edges.pop();

	        if (forest.find(edge.source) !== forest.find(edge.target)) {
	            forest.union(edge.source, edge.target);
	            selectedEdges.push(edge);
	        }
	    }

	    return {
	        nodes: vertices,
	        links: selectedEdges
	    }
	}


	function DisjointSet() {
	    this.index_ = {};
	}

	function Node(id) {
	    this.id_ = id;
	    this.parent_ = this;
	    this.rank_ = 0;
	}

	DisjointSet.prototype.makeSet = function (id) {
	    if (!this.index_[id]) {
	        let created = new Node(id);
	        this.index_[id] = created;
	    }
	};

	// Returns the id of the representative element of this set that (id)
	// belongs to.
	DisjointSet.prototype.find = function (id) {
	    if (this.index_[id] === undefined) {
	        return undefined;
	    }

	    let current = this.index_[id].parent_;
	    while (current !== current.parent_) {
	        current = current.parent_;
	    }
	    return current.id_;
	};

	DisjointSet.prototype.union = function (x, y) {
	    let xRoot = this.index_[this.find(x)];
	    let yRoot = this.index_[this.find(y)];

	    if (xRoot === undefined || yRoot === undefined || xRoot === yRoot) {
	        // x and y already belong to the same set.
	        return;
	    }

	    if (xRoot.rank < yRoot.rank) { // Move x into the set y is a member of.
	        xRoot.parent_ = yRoot;
	    } else if (yRoot.rank_ < xRoot.rank_) { // Move y into the set x is a member of.
	        yRoot.parent_ = xRoot;
	    } else { // Arbitrarily choose to move y into the set x is a member of.
	        yRoot.parent_ = xRoot;
	        xRoot.rank_++;
	    }
	};

	// Returns the current number of disjoint sets.
	DisjointSet.prototype.size = function () {
	    let uniqueIndices = {};
	    Object.keys(this.index_).forEach((id) => {
	        uniqueIndices[id] = true;
	    });
	    return Object.keys(uniqueIndices).length;
	};

	/* @flow */

	/* @flow */

	/**
	 * This computes the maximum number in an array.
	 *
	 * This runs on `O(n)`, linear time in respect to the array
	 *
	 * @param {Array<number>} x sample of one or more data points
	 * @returns {number} maximum value
	 * @throws {Error} if the the length of x is less than one
	 * @example
	 * max([1, 2, 3, 4]);
	 * // => 4
	 */
	function max(x /*: Array<number> */) /*:number*/ {

	    if (x.length === 0) {
	        throw new Error('max requires at least one data point');
	    }

	    var value = x[0];
	    for (var i = 1; i < x.length; i++) {
	        // On the first iteration of this loop, max is
	        // undefined and is thus made the maximum element in the array
	        if (x[i] > value) {
	            value = x[i];
	        }
	    }
	    return value;
	}

	/* @flow */

	/**
	 * This is the internal implementation of quantiles: when you know
	 * that the order is sorted, you don't need to re-sort it, and the computations
	 * are faster.
	 *
	 * @param {Array<number>} x sample of one or more data points
	 * @param {number} p desired quantile: a number between 0 to 1, inclusive
	 * @returns {number} quantile value
	 * @throws {Error} if p ix outside of the range from 0 to 1
	 * @throws {Error} if x is empty
	 * @example
	 * quantileSorted([3, 6, 7, 8, 8, 9, 10, 13, 15, 16, 20], 0.5); // => 9
	 */
	function quantileSorted(x /*: Array<number> */, p /*: number */)/*: number */ {
	    var idx = x.length * p;
	    if (x.length === 0) {
	        throw new Error('quantile requires at least one data point.');
	    } else if (p < 0 || p > 1) {
	        throw new Error('quantiles must be between 0 and 1');
	    } else if (p === 1) {
	        // If p is 1, directly return the last element
	        return x[x.length - 1];
	    } else if (p === 0) {
	        // If p is 0, directly return the first element
	        return x[0];
	    } else if (idx % 1 !== 0) {
	        // If p is not integer, return the next element in array
	        return x[Math.ceil(idx) - 1];
	    } else if (x.length % 2 === 0) {
	        // If the list has even-length, we'll take the average of this number
	        // and the next value, if there is one
	        return (x[idx - 1] + x[idx]) / 2;
	    } else {
	        // Finally, in the simple case of an integer value
	        // with an odd-length list, return the x value at the index.
	        return x[idx];
	    }
	}

	/* @flow */

	/**
	 * Rearrange items in `arr` so that all items in `[left, k]` range are the smallest.
	 * The `k`-th element will have the `(k - left + 1)`-th smallest value in `[left, right]`.
	 *
	 * Implements Floyd-Rivest selection algorithm https://en.wikipedia.org/wiki/Floyd-Rivest_algorithm
	 *
	 * @param {Array<number>} arr input array
	 * @param {number} k pivot index
	 * @param {number} [left] left index
	 * @param {number} [right] right index
	 * @returns {void} mutates input array
	 * @example
	 * var arr = [65, 28, 59, 33, 21, 56, 22, 95, 50, 12, 90, 53, 28, 77, 39];
	 * quickselect(arr, 8);
	 * // = [39, 28, 28, 33, 21, 12, 22, 50, 53, 56, 59, 65, 90, 77, 95]
	 */
	function quickselect(arr/*: Array<number> */, k/*: number */, left/*: ?number */, right/*: ?number */)/*: void */ {
	    left = left || 0;
	    right = right || (arr.length - 1);

	    while (right > left) {
	        // 600 and 0.5 are arbitrary constants chosen in the original paper to minimize execution time
	        if (right - left > 600) {
	            var n = right - left + 1;
	            var m = k - left + 1;
	            var z = Math.log(n);
	            var s = 0.5 * Math.exp(2 * z / 3);
	            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n);
	            if (m - n / 2 < 0) sd *= -1;
	            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
	            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
	            quickselect(arr, k, newLeft, newRight);
	        }

	        var t = arr[k];
	        var i = left;
	        var j = right;

	        swap(arr, left, k);
	        if (arr[right] > t) swap(arr, left, right);

	        while (i < j) {
	            swap(arr, i, j);
	            i++;
	            j--;
	            while (arr[i] < t) i++;
	            while (arr[j] > t) j--;
	        }

	        if (arr[left] === t) swap(arr, left, j);
	        else {
	            j++;
	            swap(arr, j, right);
	        }

	        if (j <= k) left = j + 1;
	        if (k <= j) right = j - 1;
	    }
	}

	function swap(arr, i, j) {
	    var tmp = arr[i];
	    arr[i] = arr[j];
	    arr[j] = tmp;
	}

	/* @flow */

	/**
	 * The [quantile](https://en.wikipedia.org/wiki/Quantile):
	 * this is a population quantile, since we assume to know the entire
	 * dataset in this library. This is an implementation of the
	 * [Quantiles of a Population](http://en.wikipedia.org/wiki/Quantile#Quantiles_of_a_population)
	 * algorithm from wikipedia.
	 *
	 * Sample is a one-dimensional array of numbers,
	 * and p is either a decimal number from 0 to 1 or an array of decimal
	 * numbers from 0 to 1.
	 * In terms of a k/q quantile, p = k/q - it's just dealing with fractions or dealing
	 * with decimal values.
	 * When p is an array, the result of the function is also an array containing the appropriate
	 * quantiles in input order
	 *
	 * @param {Array<number>} x sample of one or more numbers
	 * @param {Array<number> | number} p the desired quantile, as a number between 0 and 1
	 * @returns {number} quantile
	 * @example
	 * quantile([3, 6, 7, 8, 8, 9, 10, 13, 15, 16, 20], 0.5); // => 9
	 */
	function quantile(x/*: Array<number> */, p/*: Array<number> | number */)/*: Array<number> | number */ {
	    var copy = x.slice();

	    if (Array.isArray(p)) {
	        // rearrange elements so that each element corresponding to a requested
	        // quantile is on a place it would be if the array was fully sorted
	        multiQuantileSelect(copy, p);
	        // Initialize the result array
	        var results = [];
	        // For each requested quantile
	        for (var i = 0; i < p.length; i++) {
	            results[i] = quantileSorted(copy, p[i]);
	        }
	        return results;
	    } else {
	        var idx = quantileIndex(copy.length, p);
	        quantileSelect(copy, idx, 0, copy.length - 1);
	        return quantileSorted(copy, p);
	    }
	}

	function quantileSelect(arr, k, left, right) {
	    if (k % 1 === 0) {
	        quickselect(arr, k, left, right);
	    } else {
	        k = Math.floor(k);
	        quickselect(arr, k, left, right);
	        quickselect(arr, k + 1, k + 1, right);
	    }
	}

	function multiQuantileSelect(arr, p) {
	    var indices = [0];
	    for (var i = 0; i < p.length; i++) {
	        indices.push(quantileIndex(arr.length, p[i]));
	    }
	    indices.push(arr.length - 1);
	    indices.sort(compare);

	    var stack = [0, indices.length - 1];

	    while (stack.length) {
	        var r = Math.ceil(stack.pop());
	        var l = Math.floor(stack.pop());
	        if (r - l <= 1) continue;

	        var m = Math.floor((l + r) / 2);
	        quantileSelect(arr, indices[m], indices[l], indices[r]);

	        stack.push(l, m, m, r);
	    }
	}

	function compare(a, b) {
	    return a - b;
	}

	function quantileIndex(len /*: number */, p /*: number */)/*:number*/ {
	    var idx = len * p;
	    if (p === 1) {
	        // If p is 1, directly return the last index
	        return len - 1;
	    } else if (p === 0) {
	        // If p is 0, directly return the first index
	        return 0;
	    } else if (idx % 1 !== 0) {
	        // If index is not integer, return the next index in array
	        return Math.ceil(idx) - 1;
	    } else if (len % 2 === 0) {
	        // If the list has even-length, we'll return the middle of two indices
	        // around quantile to indicate that we need an average value of the two
	        return idx - 0.5;
	    } else {
	        // Finally, in the simple case of an integer index
	        // with an odd-length list, return the index
	        return idx;
	    }
	}
	var LOGSQRT2PI = Math.log(Math.sqrt(2 * Math.PI));

	/* @flow */

	var SQRT_2PI = Math.sqrt(2 * Math.PI);

	/* @flow */

	var SQRT_2PI$1 = Math.sqrt(2 * Math.PI);

	class Clumpy {
	    constructor(tree) {
	        //Clone the tree to avoid modifying it
	        this.tree = JSON.parse(JSON.stringify(tree));
	    }

	    /**
	     * Returns clumpy score
	     * @returns {number}
	     */
	    score() {
	        let allRuntRatios = [];
	        this.tree.links.forEach(link =>{
	            let rg = this.runtGraph(link);
	            if(rg.length>0){
	                allRuntRatios.push(this.maxLength(rg)/link.weight);
	            }
	        });
	        if(allRuntRatios.length>0){
	            //Only if there are some runt graphs
	            return max(allRuntRatios.map(rr=>1-rr));
	        }else{
	            //In case all lengths are equal => then the score is 0
	            return 0;
	        }
	    }
	    // score() {
	    //     return max(this.tree.links.map(link=>1-this.maxLength(this.runtGraph(link))/link.weight));
	    // }
	    // runtGraph(link){
	    //     let greaterOrEqualLinks = this.tree.links.filter(l=>l.weight >= link.weight);
	    //     //Remove the currently checking link.
	    //     greaterOrEqualLinks = greaterOrEqualLinks.filter(l=>!equalLinks(l, link));
	    //     let pairedResults = pairNodeLinks(greaterOrEqualLinks);
	    //
	    //     //Process the source side.
	    //     let sourceConnectedNodes = [link.source];
	    //     let sourceConnectedLinks = this.getConnectedLinks(sourceConnectedNodes, pairedResults);
	    //
	    //     let targetConnectedNodes = [link.target];
	    //     let targetConnectedLinks = this.getConnectedLinks(targetConnectedNodes, pairedResults);
	    //
	    //     return sourceConnectedLinks.length < targetConnectedLinks.length?sourceConnectedLinks:targetConnectedLinks;
	    // }
	    runtGraph(link){
	        let greaterOrEqualLinks = this.tree.links.filter(l=>l.weight < link.weight);
	        //Remove the currently checking link.
	        greaterOrEqualLinks = greaterOrEqualLinks.filter(l=>!equalLinks(l, link));
	        let pairedResults = pairNodeLinks(greaterOrEqualLinks);

	        //Process the source side.
	        let sourceConnectedNodes = [link.source];
	        let sourceConnectedLinks = this.getConnectedLinks(sourceConnectedNodes, pairedResults);

	        let targetConnectedNodes = [link.target];
	        let targetConnectedLinks = this.getConnectedLinks(targetConnectedNodes, pairedResults);

	        return sourceConnectedLinks.length < targetConnectedLinks.length?sourceConnectedLinks:targetConnectedLinks;
	    }


	    getConnectedLinks(connectedNodes, pairedResults) {
	        let processedNodes = [];
	        let connectedLinks = [];
	        while (connectedNodes.length > 0) {
	            //Can stop earlier if this is having more than half of the links in the whole tree.
	            if(connectedLinks.length > this.tree.links.length + 1){
	                break;
	            }
	            let firstNode = underscore.first(connectedNodes);
	            //Removed the processed nodes
	            connectedNodes = underscore.without(connectedNodes, firstNode);
	            //Add it to the processed node
	            processedNodes.push(firstNode);
	            //Find the edges connected to that node.
	            let result = pairedResults.find(p => p[0] === firstNode.join(","));
	            let links = result?result[1]:[];
	            connectedLinks = connectedLinks.concat(links);
	            //Add new nodes to be processed
	            links.forEach(l => {
	                //If the node in the connected link is not processed => then add it to be processed (to expand later on).
	                if (!pointExists(processedNodes, l.source)) {
	                    connectedNodes.push(l.source);
	                }
	                if(!pointExists(processedNodes, l.target)) {
	                    connectedNodes.push(l.target);
	                }
	            });
	        }
	        return connectedLinks;
	    }

	    maxLength(runtGraph){
	        if(runtGraph.length===0){
	            return 0;
	        }
	        return max(runtGraph.map(l=>l.weight));
	    }
	}
	function pointExists(points, point){
	    for (let i = 0; i < points.length; i++) {
	        let point1 = points[i];
	        if (equalPoints(point1, point)) {
	            return true;
	        }
	    }
	    return false;
	}

	const EPSILON = Math.pow(2, -52);

	class Delaunator {

	    static from(points, getX, getY) {
	        if (!getX) getX = defaultGetX;
	        if (!getY) getY = defaultGetY;

	        const n = points.length;
	        const coords = new Float64Array(n * 2);

	        for (let i = 0; i < n; i++) {
	            const p = points[i];
	            coords[2 * i] = getX(p);
	            coords[2 * i + 1] = getY(p);
	        }

	        return new Delaunator(coords);
	    }

	    constructor(coords) {
	        let minX = Infinity;
	        let minY = Infinity;
	        let maxX = -Infinity;
	        let maxY = -Infinity;

	        const n = coords.length >> 1;
	        const ids = this.ids = new Uint32Array(n);

	        if (n > 0 && typeof coords[0] !== 'number') throw new Error('Expected coords to contain numbers.');

	        this.coords = coords;

	        for (let i = 0; i < n; i++) {
	            const x = coords[2 * i];
	            const y = coords[2 * i + 1];
	            if (x < minX) minX = x;
	            if (y < minY) minY = y;
	            if (x > maxX) maxX = x;
	            if (y > maxY) maxY = y;
	            ids[i] = i;
	        }

	        const cx = (minX + maxX) / 2;
	        const cy = (minY + maxY) / 2;

	        let minDist = Infinity;
	        let i0, i1, i2;

	        // pick a seed point close to the centroid
	        for (let i = 0; i < n; i++) {
	            const d = dist(cx, cy, coords[2 * i], coords[2 * i + 1]);
	            if (d < minDist) {
	                i0 = i;
	                minDist = d;
	            }
	        }
	        const i0x = coords[2 * i0];
	        const i0y = coords[2 * i0 + 1];

	        minDist = Infinity;

	        // find the point closest to the seed
	        for (let i = 0; i < n; i++) {
	            if (i === i0) continue;
	            const d = dist(i0x, i0y, coords[2 * i], coords[2 * i + 1]);
	            if (d < minDist && d > 0) {
	                i1 = i;
	                minDist = d;
	            }
	        }
	        let i1x = coords[2 * i1];
	        let i1y = coords[2 * i1 + 1];

	        let minRadius = Infinity;

	        // find the third point which forms the smallest circumcircle with the first two
	        for (let i = 0; i < n; i++) {
	            if (i === i0 || i === i1) continue;
	            const r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);
	            if (r < minRadius) {
	                i2 = i;
	                minRadius = r;
	            }
	        }
	        let i2x = coords[2 * i2];
	        let i2y = coords[2 * i2 + 1];

	        if (minRadius === Infinity) {
	            throw new Error('No Delaunay triangulation exists for this input.');
	        }

	        // swap the order of the seed points for counter-clockwise orientation
	        if (orient(i0x, i0y, i1x, i1y, i2x, i2y)) {
	            const i = i1;
	            const x = i1x;
	            const y = i1y;
	            i1 = i2;
	            i1x = i2x;
	            i1y = i2y;
	            i2 = i;
	            i2x = x;
	            i2y = y;
	        }

	        const center = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);
	        this._cx = center.x;
	        this._cy = center.y;

	        // sort the points by distance from the seed triangle circumcenter
	        quicksort(ids, coords, 0, ids.length - 1, center.x, center.y);

	        // initialize a hash table for storing edges of the advancing convex hull
	        this._hashSize = Math.ceil(Math.sqrt(n));
	        this._hash = new Array(this._hashSize);

	        // initialize a circular doubly-linked list that will hold an advancing convex hull
	        let e = this.hull = insertNode(coords, i0);
	        this._hashEdge(e);
	        e.t = 0;
	        e = insertNode(coords, i1, e);
	        this._hashEdge(e);
	        e.t = 1;
	        e = insertNode(coords, i2, e);
	        this._hashEdge(e);
	        e.t = 2;

	        const maxTriangles = 2 * n - 5;
	        const triangles = this.triangles = new Uint32Array(maxTriangles * 3);
	        const halfedges = this.halfedges = new Int32Array(maxTriangles * 3);

	        this.trianglesLen = 0;

	        this._addTriangle(i0, i1, i2, -1, -1, -1);

	        for (let k = 0, xp, yp; k < ids.length; k++) {
	            const i = ids[k];
	            const x = coords[2 * i];
	            const y = coords[2 * i + 1];

	            // skip near-duplicate points
	            if (k > 0 && Math.abs(x - xp) <= EPSILON && Math.abs(y - yp) <= EPSILON) continue;
	            xp = x;
	            yp = y;

	            // skip seed triangle points
	            if (i === i0 || i === i1 || i === i2) continue;

	            // find a visible edge on the convex hull using edge hash
	            const startKey = this._hashKey(x, y);
	            let key = startKey;
	            let start;
	            do {
	                start = this._hash[key];
	                key = (key + 1) % this._hashSize;
	            } while ((!start || start.removed) && key !== startKey);

	            start = start.prev;
	            e = start;
	            while (!orient(x, y, e.x, e.y, e.next.x, e.next.y)) {
	                e = e.next;
	                if (e === start) {
	                    e = null;
	                    break;
	                }
	            }
	            // likely a near-duplicate point; skip it
	            if (!e) continue;

	            const walkBack = e === start;

	            // add the first triangle from the point
	            let t = this._addTriangle(e.i, i, e.next.i, -1, -1, e.t);

	            e.t = t; // keep track of boundary triangles on the hull
	            e = insertNode(coords, i, e);

	            // recursively flip triangles from the point until they satisfy the Delaunay condition
	            e.t = this._legalize(t + 2);

	            // walk forward through the hull, adding more triangles and flipping recursively
	            let q = e.next;
	            while (orient(x, y, q.x, q.y, q.next.x, q.next.y)) {
	                t = this._addTriangle(q.i, i, q.next.i, q.prev.t, -1, q.t);
	                q.prev.t = this._legalize(t + 2);
	                this.hull = removeNode(q);
	                q = q.next;
	            }

	            if (walkBack) {
	                // walk backward from the other side, adding more triangles and flipping
	                q = e.prev;
	                while (orient(x, y, q.prev.x, q.prev.y, q.x, q.y)) {
	                    t = this._addTriangle(q.prev.i, i, q.i, -1, q.t, q.prev.t);
	                    this._legalize(t + 2);
	                    q.prev.t = t;
	                    this.hull = removeNode(q);
	                    q = q.prev;
	                }
	            }

	            // save the two new edges in the hash table
	            this._hashEdge(e);
	            this._hashEdge(e.prev);
	        }

	        // trim typed triangle mesh arrays
	        this.triangles = triangles.subarray(0, this.trianglesLen);
	        this.halfedges = halfedges.subarray(0, this.trianglesLen);
	    }

	    _hashEdge(e) {
	        this._hash[this._hashKey(e.x, e.y)] = e;
	    }

	    _hashKey(x, y) {
	        return Math.floor(pseudoAngle(x - this._cx, y - this._cy) * this._hashSize) % this._hashSize;
	    }

	    _legalize(a) {
	        const {triangles, coords, halfedges} = this;

	        const b = halfedges[a];

	        /* if the pair of triangles doesn't satisfy the Delaunay condition
	         * (p1 is inside the circumcircle of [p0, pl, pr]), flip them,
	         * then do the same check/flip recursively for the new pair of triangles
	         *
	         *           pl                    pl
	         *          /||\                  /  \
	         *       al/ || \bl            al/    \a
	         *        /  ||  \              /      \
	         *       /  a||b  \    flip    /___ar___\
	         *     p0\   ||   /p1   =>   p0\---bl---/p1
	         *        \  ||  /              \      /
	         *       ar\ || /br             b\    /br
	         *          \||/                  \  /
	         *           pr                    pr
	         */
	        const a0 = a - a % 3;
	        const b0 = b - b % 3;

	        const al = a0 + (a + 1) % 3;
	        const ar = a0 + (a + 2) % 3;
	        const bl = b0 + (b + 2) % 3;

	        if (b === -1) return ar;

	        const p0 = triangles[ar];
	        const pr = triangles[a];
	        const pl = triangles[al];
	        const p1 = triangles[bl];

	        const illegal = inCircle(
	            coords[2 * p0], coords[2 * p0 + 1],
	            coords[2 * pr], coords[2 * pr + 1],
	            coords[2 * pl], coords[2 * pl + 1],
	            coords[2 * p1], coords[2 * p1 + 1]);

	        if (illegal) {
	            triangles[a] = p1;
	            triangles[b] = p0;

	            const hbl = halfedges[bl];

	            // edge swapped on the other side of the hull (rare); fix the halfedge reference
	            if (hbl === -1) {
	                let e = this.hull;
	                do {
	                    if (e.t === bl) {
	                        e.t = a;
	                        break;
	                    }
	                    e = e.next;
	                } while (e !== this.hull);
	            }
	            this._link(a, hbl);
	            this._link(b, halfedges[ar]);
	            this._link(ar, bl);

	            const br = b0 + (b + 1) % 3;

	            this._legalize(a);
	            return this._legalize(br);
	        }

	        return ar;
	    }

	    _link(a, b) {
	        this.halfedges[a] = b;
	        if (b !== -1) this.halfedges[b] = a;
	    }

	    // add a new triangle given vertex indices and adjacent half-edge ids
	    _addTriangle(i0, i1, i2, a, b, c) {
	        const t = this.trianglesLen;

	        this.triangles[t] = i0;
	        this.triangles[t + 1] = i1;
	        this.triangles[t + 2] = i2;

	        this._link(t, a);
	        this._link(t + 1, b);
	        this._link(t + 2, c);

	        this.trianglesLen += 3;

	        return t;
	    }
	}

	// monotonically increases with real angle, but doesn't need expensive trigonometry
	function pseudoAngle(dx, dy) {
	    const p = dx / (Math.abs(dx) + Math.abs(dy));
	    return (dy > 0 ? 3 - p : 1 + p) / 4; // [0..1]
	}

	function dist(ax, ay, bx, by) {
	    const dx = ax - bx;
	    const dy = ay - by;
	    return dx * dx + dy * dy;
	}

	function orient(px, py, qx, qy, rx, ry) {
	    return (qy - py) * (rx - qx) - (qx - px) * (ry - qy) < 0;
	}

	function inCircle(ax, ay, bx, by, cx, cy, px, py) {
	    const dx = ax - px;
	    const dy = ay - py;
	    const ex = bx - px;
	    const ey = by - py;
	    const fx = cx - px;
	    const fy = cy - py;

	    const ap = dx * dx + dy * dy;
	    const bp = ex * ex + ey * ey;
	    const cp = fx * fx + fy * fy;

	    return dx * (ey * cp - bp * fy) -
	           dy * (ex * cp - bp * fx) +
	           ap * (ex * fy - ey * fx) < 0;
	}

	function circumradius(ax, ay, bx, by, cx, cy) {
	    const dx = bx - ax;
	    const dy = by - ay;
	    const ex = cx - ax;
	    const ey = cy - ay;

	    const bl = dx * dx + dy * dy;
	    const cl = ex * ex + ey * ey;
	    const d = dx * ey - dy * ex;

	    const x = (ey * bl - dy * cl) * 0.5 / d;
	    const y = (dx * cl - ex * bl) * 0.5 / d;

	    return bl && cl && d && (x * x + y * y) || Infinity;
	}

	function circumcenter(ax, ay, bx, by, cx, cy) {
	    const dx = bx - ax;
	    const dy = by - ay;
	    const ex = cx - ax;
	    const ey = cy - ay;

	    const bl = dx * dx + dy * dy;
	    const cl = ex * ex + ey * ey;
	    const d = dx * ey - dy * ex;

	    const x = ax + (ey * bl - dy * cl) * 0.5 / d;
	    const y = ay + (dx * cl - ex * bl) * 0.5 / d;

	    return {x, y};
	}

	// create a new node in a doubly linked list
	function insertNode(coords, i, prev) {
	    const node = {
	        i,
	        x: coords[2 * i],
	        y: coords[2 * i + 1],
	        t: 0,
	        prev: null,
	        next: null,
	        removed: false
	    };

	    if (!prev) {
	        node.prev = node;
	        node.next = node;

	    } else {
	        node.next = prev.next;
	        node.prev = prev;
	        prev.next.prev = node;
	        prev.next = node;
	    }
	    return node;
	}

	function removeNode(node) {
	    node.prev.next = node.next;
	    node.next.prev = node.prev;
	    node.removed = true;
	    return node.prev;
	}

	function quicksort(ids, coords, left, right, cx, cy) {
	    let i, j, temp;

	    if (right - left <= 20) {
	        for (i = left + 1; i <= right; i++) {
	            temp = ids[i];
	            j = i - 1;
	            while (j >= left && compare$1(coords, ids[j], temp, cx, cy) > 0) ids[j + 1] = ids[j--];
	            ids[j + 1] = temp;
	        }
	    } else {
	        const median = (left + right) >> 1;
	        i = left + 1;
	        j = right;
	        swap$1(ids, median, i);
	        if (compare$1(coords, ids[left], ids[right], cx, cy) > 0) swap$1(ids, left, right);
	        if (compare$1(coords, ids[i], ids[right], cx, cy) > 0) swap$1(ids, i, right);
	        if (compare$1(coords, ids[left], ids[i], cx, cy) > 0) swap$1(ids, left, i);

	        temp = ids[i];
	        while (true) {
	            do i++; while (compare$1(coords, ids[i], temp, cx, cy) < 0);
	            do j--; while (compare$1(coords, ids[j], temp, cx, cy) > 0);
	            if (j < i) break;
	            swap$1(ids, i, j);
	        }
	        ids[left + 1] = ids[j];
	        ids[j] = temp;

	        if (right - i + 1 >= j - left) {
	            quicksort(ids, coords, i, right, cx, cy);
	            quicksort(ids, coords, left, j - 1, cx, cy);
	        } else {
	            quicksort(ids, coords, left, j - 1, cx, cy);
	            quicksort(ids, coords, i, right, cx, cy);
	        }
	    }
	}

	function compare$1(coords, i, j, cx, cy) {
	    const d1 = dist(coords[2 * i], coords[2 * i + 1], cx, cy);
	    const d2 = dist(coords[2 * j], coords[2 * j + 1], cx, cy);
	    return (d1 - d2) || (coords[2 * i] - coords[2 * j]) || (coords[2 * i + 1] - coords[2 * j + 1]);
	}

	function swap$1(arr, i, j) {
	    const tmp = arr[i];
	    arr[i] = arr[j];
	    arr[j] = tmp;
	}

	function defaultGetX(p) {
	    return p[0];
	}
	function defaultGetY(p) {
	    return p[1];
	}

	const epsilon$1 = 1e-6;

	class Path {
	  constructor() {
	    this._x0 = this._y0 = // start of current subpath
	    this._x1 = this._y1 = null; // end of current subpath
	    this._ = "";
	  }
	  moveTo(x, y) {
	    this._ += `M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}`;
	  }
	  closePath() {
	    if (this._x1 !== null) {
	      this._x1 = this._x0, this._y1 = this._y0;
	      this._ += "Z";
	    }
	  }
	  lineTo(x, y) {
	    this._ += `L${this._x1 = +x},${this._y1 = +y}`;
	  }
	  arc(x, y, r) {
	    x = +x, y = +y, r = +r;
	    const x0 = x + r;
	    const y0 = y;
	    if (r < 0) throw new Error("negative radius");
	    if (this._x1 === null) this._ += `M${x0},${y0}`;
	    else if (Math.abs(this._x1 - x0) > epsilon$1 || Math.abs(this._y1 - y0) > epsilon$1) this._ += "L" + x0 + "," + y0;
	    if (!r) return;
	    this._ += `A${r},${r},0,1,1,${x - r},${y}A${r},${r},0,1,1,${this._x1 = x0},${this._y1 = y0}`;
	  }
	  rect(x, y, w, h) {
	    this._ += `M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}h${+w}v${+h}h${-w}Z`;
	  }
	  value() {
	    return this._ || null;
	  }
	}

	class Polygon {
	  constructor() {
	    this._ = [];
	  }
	  moveTo(x, y) {
	    this._.push([x, y]);
	  }
	  closePath() {
	    this._.push(this._[0].slice());
	  }
	  lineTo(x, y) {
	    this._.push([x, y]);
	  }
	  value() {
	    return this._.length ? this._ : null;
	  }
	}

	class Voronoi {
	  constructor(delaunay, [xmin, ymin, xmax, ymax] = [0, 0, 960, 500]) {
	    if (!((xmax = +xmax) >= (xmin = +xmin)) || !((ymax = +ymax) >= (ymin = +ymin))) throw new Error("invalid bounds");
	    const {points, hull, triangles} = this.delaunay = delaunay;
	    const circumcenters = this.circumcenters = new Float64Array(triangles.length / 3 * 2);
	    const vectors = this.vectors = new Float64Array(points.length * 2);
	    this.xmax = xmax, this.xmin = xmin;
	    this.ymax = ymax, this.ymin = ymin;

	    // Compute circumcenters.
	    for (let i = 0, j = 0, n = triangles.length; i < n; i += 3, j += 2) {
	      const t1 = triangles[i] * 2;
	      const t2 = triangles[i + 1] * 2;
	      const t3 = triangles[i + 2] * 2;
	      const x1 = points[t1];
	      const y1 = points[t1 + 1];
	      const x2 = points[t2];
	      const y2 = points[t2 + 1];
	      const x3 = points[t3];
	      const y3 = points[t3 + 1];
	      const a2 = x1 - x2;
	      const a3 = x1 - x3;
	      const b2 = y1 - y2;
	      const b3 = y1 - y3;
	      const d1 = x1 * x1 + y1 * y1;
	      const d2 = d1 - x2 * x2 - y2 * y2;
	      const d3 = d1 - x3 * x3 - y3 * y3;
	      const ab = (a3 * b2 - a2 * b3) * 2;
	      circumcenters[j] = (b2 * d3 - b3 * d2) / ab;
	      circumcenters[j + 1] = (a3 * d2 - a2 * d3) / ab;
	    }

	    // Compute exterior cell rays.
	    let node = hull;
	    let p0, p1 = node.i * 4;
	    let x0, x1 = node.x;
	    let y0, y1 = node.y;
	    do {
	      node = node.next, p0 = p1, x0 = x1, y0 = y1, p1 = node.i * 4, x1 = node.x, y1 = node.y;
	      vectors[p0 + 2] = vectors[p1] = y0 - y1;
	      vectors[p0 + 3] = vectors[p1 + 1] = x1 - x0;
	    } while (node !== hull);
	  }
	  render(context) {
	    const buffer = context == null ? context = new Path : undefined;
	    const {delaunay: {halfedges, hull}, circumcenters, vectors} = this;
	    for (let i = 0, n = halfedges.length; i < n; ++i) {
	      const j = halfedges[i];
	      if (j < i) continue;
	      const ti = Math.floor(i / 3) * 2;
	      const tj = Math.floor(j / 3) * 2;
	      const xi = circumcenters[ti];
	      const yi = circumcenters[ti + 1];
	      const xj = circumcenters[tj];
	      const yj = circumcenters[tj + 1];
	      this._renderSegment(xi, yi, xj, yj, context);
	    }
	    let node = hull;
	    do {
	      node = node.next;
	      const t = Math.floor(node.t / 3) * 2;
	      const x = circumcenters[t];
	      const y = circumcenters[t + 1];
	      const v = node.i * 4;
	      const p = this._project(x, y, vectors[v + 2], vectors[v + 3]);
	      if (p) this._renderSegment(x, y, p[0], p[1], context);
	    } while (node !== hull);
	    return buffer && buffer.value();
	  }
	  renderBounds(context) {
	    const buffer = context == null ? context = new Path : undefined;
	    context.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);
	    return buffer && buffer.value();
	  }
	  renderCell(i, context) {
	    const buffer = context == null ? context = new Path : undefined;
	    const points = this._clip(i);
	    if (points === null) return;
	    context.moveTo(points[0], points[1]);
	    for (let i = 2, n = points.length; i < n; i += 2) {
	      context.lineTo(points[i], points[i + 1]);
	    }
	    context.closePath();
	    return buffer && buffer.value();
	  }
	  *cellPolygons() {
	    const {delaunay: {points}} = this;
	    for (let i = 0, n = points.length / 2; i < n; ++i) {
	      const cell = this.cellPolygon(i);
	      if (cell) yield cell;
	    }
	  }
	  cellPolygon(i) {
	    const polygon = new Polygon;
	    this.renderCell(i, polygon);
	    return polygon.value();
	  }
	  _renderSegment(x0, y0, x1, y1, context) {
	    let S;
	    const c0 = this._regioncode(x0, y0);
	    const c1 = this._regioncode(x1, y1);
	    if (c0 === 0 && c1 === 0) {
	      context.moveTo(x0, y0);
	      context.lineTo(x1, y1);
	    } else if (S = this._clipSegment(x0, y0, x1, y1, c0, c1)) {
	      context.moveTo(S[0], S[1]);
	      context.lineTo(S[2], S[3]);
	    }
	  }
	  contains(i, x, y) {
	    if ((x = +x, x !== x) || (y = +y, y !== y)) return false;
	    return this.delaunay._step(i, x, y) === i;
	  }
	  _cell(i) {
	    const {circumcenters, delaunay: {inedges, halfedges, triangles}} = this;
	    const e0 = inedges[i];
	    if (e0 === -1) return null; // coincident point
	    const points = [];
	    let e = e0;
	    do {
	      const t = Math.floor(e / 3);
	      points.push(circumcenters[t * 2], circumcenters[t * 2 + 1]);
	      e = e % 3 === 2 ? e - 2 : e + 1;
	      if (triangles[e] !== i) break; // bad triangulation
	      e = halfedges[e];
	    } while (e !== e0 && e !== -1);
	    return points;
	  }
	  _clip(i) {
	    const points = this._cell(i);
	    if (points === null) return null;
	    const {vectors: V} = this;
	    const v = i * 4;
	    return V[v] || V[v + 1]
	        ? this._clipInfinite(i, points, V[v], V[v + 1], V[v + 2], V[v + 3])
	        : this._clipFinite(i, points);
	  }
	  _clipFinite(i, points) {
	    const n = points.length;
	    let P = null;
	    let x0, y0, x1 = points[n - 2], y1 = points[n - 1];
	    let c0, c1 = this._regioncode(x1, y1);
	    let e0, e1;
	    for (let j = 0; j < n; j += 2) {
	      x0 = x1, y0 = y1, x1 = points[j], y1 = points[j + 1];
	      c0 = c1, c1 = this._regioncode(x1, y1);
	      if (c0 === 0 && c1 === 0) {
	        e0 = e1, e1 = 0;
	        if (P) P.push(x1, y1);
	        else P = [x1, y1];
	      } else {
	        let S, sx0, sy0, sx1, sy1;
	        if (c0 === 0) {
	          if ((S = this._clipSegment(x0, y0, x1, y1, c0, c1)) === null) continue;
	          [sx0, sy0, sx1, sy1] = S;
	        } else {
	          if ((S = this._clipSegment(x1, y1, x0, y0, c1, c0)) === null) continue;
	          [sx1, sy1, sx0, sy0] = S;
	          e0 = e1, e1 = this._edgecode(sx0, sy0);
	          if (e0 && e1) this._edge(i, e0, e1, P, P.length);
	          if (P) P.push(sx0, sy0);
	          else P = [sx0, sy0];
	        }
	        e0 = e1, e1 = this._edgecode(sx1, sy1);
	        if (e0 && e1) this._edge(i, e0, e1, P, P.length);
	        if (P) P.push(sx1, sy1);
	        else P = [sx1, sy1];
	      }
	    }
	    if (P) {
	      e0 = e1, e1 = this._edgecode(P[0], P[1]);
	      if (e0 && e1) this._edge(i, e0, e1, P, P.length);
	    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
	      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
	    }
	    return P;
	  }
	  _clipSegment(x0, y0, x1, y1, c0, c1) {
	    while (true) {
	      if (c0 === 0 && c1 === 0) return [x0, y0, x1, y1];
	      if (c0 & c1) return null;
	      let x, y, c = c0 || c1;
	      if (c & 0b1000) x = x0 + (x1 - x0) * (this.ymax - y0) / (y1 - y0), y = this.ymax;
	      else if (c & 0b0100) x = x0 + (x1 - x0) * (this.ymin - y0) / (y1 - y0), y = this.ymin;
	      else if (c & 0b0010) y = y0 + (y1 - y0) * (this.xmax - x0) / (x1 - x0), x = this.xmax;
	      else y = y0 + (y1 - y0) * (this.xmin - x0) / (x1 - x0), x = this.xmin;
	      if (c0) x0 = x, y0 = y, c0 = this._regioncode(x0, y0);
	      else x1 = x, y1 = y, c1 = this._regioncode(x1, y1);
	    }
	  }
	  _clipInfinite(i, points, vx0, vy0, vxn, vyn) {
	    let P = Array.from(points), p;
	    if (p = this._project(P[0], P[1], vx0, vy0)) P.unshift(p[0], p[1]);
	    if (p = this._project(P[P.length - 2], P[P.length - 1], vxn, vyn)) P.push(p[0], p[1]);
	    if (P = this._clipFinite(i, P)) {
	      for (let j = 0, n = P.length, c0, c1 = this._edgecode(P[n - 2], P[n - 1]); j < n; j += 2) {
	        c0 = c1, c1 = this._edgecode(P[j], P[j + 1]);
	        if (c0 && c1) j = this._edge(i, c0, c1, P, j), n = P.length;
	      }
	    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
	      P = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax];
	    }
	    return P;
	  }
	  _edge(i, e0, e1, P, j) {
	    while (e0 !== e1) {
	      let x, y;
	      switch (e0) {
	        case 0b0101: e0 = 0b0100; continue; // top-left
	        case 0b0100: e0 = 0b0110, x = this.xmax, y = this.ymin; break; // top
	        case 0b0110: e0 = 0b0010; continue; // top-right
	        case 0b0010: e0 = 0b1010, x = this.xmax, y = this.ymax; break; // right
	        case 0b1010: e0 = 0b1000; continue; // bottom-right
	        case 0b1000: e0 = 0b1001, x = this.xmin, y = this.ymax; break; // bottom
	        case 0b1001: e0 = 0b0001; continue; // bottom-left
	        case 0b0001: e0 = 0b0101, x = this.xmin, y = this.ymin; break; // left
	      }
	      if ((P[j] !== x || P[j + 1] !== y) && this.contains(i, x, y)) {
	        P.splice(j, 0, x, y), j += 2;
	      }
	    }
	    return j;
	  }
	  _project(x0, y0, vx, vy) {
	    let t = Infinity, c, x, y;
	    if (vy < 0) { // top
	      if (y0 <= this.ymin) return null;
	      if ((c = (this.ymin - y0) / vy) < t) y = this.ymin, x = x0 + (t = c) * vx;
	    } else if (vy > 0) { // bottom
	      if (y0 >= this.ymax) return null;
	      if ((c = (this.ymax - y0) / vy) < t) y = this.ymax, x = x0 + (t = c) * vx;
	    }
	    if (vx > 0) { // right
	      if (x0 >= this.xmax) return null;
	      if ((c = (this.xmax - x0) / vx) < t) x = this.xmax, y = y0 + (t = c) * vy;
	    } else if (vx < 0) { // left
	      if (x0 <= this.xmin) return null;
	      if ((c = (this.xmin - x0) / vx) < t) x = this.xmin, y = y0 + (t = c) * vy;
	    }
	    return [x, y];
	  }
	  _edgecode(x, y) {
	    return (x === this.xmin ? 0b0001
	        : x === this.xmax ? 0b0010 : 0b0000)
	        | (y === this.ymin ? 0b0100
	        : y === this.ymax ? 0b1000 : 0b0000);
	  }
	  _regioncode(x, y) {
	    return (x < this.xmin ? 0b0001
	        : x > this.xmax ? 0b0010 : 0b0000)
	        | (y < this.ymin ? 0b0100
	        : y > this.ymax ? 0b1000 : 0b0000);
	  }
	}

	const tau = 2 * Math.PI;

	function pointX(p) {
	  return p[0];
	}

	function pointY(p) {
	  return p[1];
	}

	class Delaunay {
	  constructor(points) {
	    const {halfedges, hull, triangles} = new Delaunator(points);
	    this.points = points;
	    this.halfedges = halfedges;
	    this.hull = hull;
	    this.triangles = triangles;
	    const inedges = this.inedges = new Int32Array(points.length / 2).fill(-1);
	    const outedges = this.outedges = new Int32Array(points.length / 2).fill(-1);

	    // Compute an index from each point to an (arbitrary) incoming halfedge.
	    for (let e = 0, n = halfedges.length; e < n; ++e) {
	      inedges[triangles[e % 3 === 2 ? e - 2 : e + 1]] = e;
	    }

	    // For points on the hull, index both the incoming and outgoing halfedges.
	    let node0, node1 = hull;
	    do {
	      node0 = node1, node1 = node1.next;
	      inedges[node1.i] = node0.t;
	      outedges[node0.i] = node1.t;
	    } while (node1 !== hull);
	  }
	  voronoi(bounds) {
	    return new Voronoi(this, bounds);
	  }
	  *neighbors(i) {
	    const {inedges, outedges, halfedges, triangles} = this;
	    const e0 = inedges[i];
	    if (e0 === -1) return; // coincident point
	    let e = e0;
	    do {
	      yield triangles[e];
	      e = e % 3 === 2 ? e - 2 : e + 1;
	      if (triangles[e] !== i) return; // bad triangulation
	      e = halfedges[e];
	      if (e === -1) return yield triangles[outedges[i]];
	    } while (e !== e0);
	  }
	  find(x, y, i = 0) {
	    if ((x = +x, x !== x) || (y = +y, y !== y)) return -1;
	    let c;
	    while ((c = this._step(i, x, y)) >= 0 && c !== i) i = c;
	    return c;
	  }
	  _step(i, x, y) {
	    const {inedges, points} = this;
	    if (inedges[i] === -1) return -1; // coincident point
	    let c = i;
	    let dc = (x - points[i * 2]) ** 2 + (y - points[i * 2 + 1]) ** 2;
	    for (const t of this.neighbors(i)) {
	      const dt = (x - points[t * 2]) ** 2 + (y - points[t * 2 + 1]) ** 2;
	      if (dt < dc) dc = dt, c = t;
	    }
	    return c;
	  }
	  render(context) {
	    const buffer = context == null ? context = new Path : undefined;
	    const {points, halfedges, triangles} = this;
	    for (let i = 0, n = halfedges.length; i < n; ++i) {
	      const j = halfedges[i];
	      if (j < i) continue;
	      const ti = triangles[i] * 2;
	      const tj = triangles[j] * 2;
	      context.moveTo(points[ti], points[ti + 1]);
	      context.lineTo(points[tj], points[tj + 1]);
	    }
	    this.renderHull(context);
	    return buffer && buffer.value();
	  }
	  renderPoints(context, r = 2) {
	    const buffer = context == null ? context = new Path : undefined;
	    const {points} = this;
	    for (let i = 0, n = points.length; i < n; i += 2) {
	      const x = points[i], y = points[i + 1];
	      context.moveTo(x + r, y);
	      context.arc(x, y, r, 0, tau);
	    }
	    return buffer && buffer.value();
	  }
	  renderHull(context) {
	    const buffer = context == null ? context = new Path : undefined;
	    const {hull} = this;
	    let node = hull;
	    context.moveTo(node.x, node.y);
	    while (node = node.next, node !== hull) context.lineTo(node.x, node.y);
	    context.closePath();
	    return buffer && buffer.value();
	  }
	  hullPolygon() {
	    const polygon = new Polygon;
	    this.renderHull(polygon);
	    return polygon.value();
	  }
	  renderTriangle(i, context) {
	    const buffer = context == null ? context = new Path : undefined;
	    const {points, triangles} = this;
	    const t0 = triangles[i *= 3] * 2;
	    const t1 = triangles[i + 1] * 2;
	    const t2 = triangles[i + 2] * 2;
	    context.moveTo(points[t0], points[t0 + 1]);
	    context.lineTo(points[t1], points[t1 + 1]);
	    context.lineTo(points[t2], points[t2 + 1]);
	    context.closePath();
	    return buffer && buffer.value();
	  }
	  *trianglePolygons() {
	    const {triangles} = this;
	    for (let i = 0, n = triangles.length / 3; i < n; ++i) {
	      yield this.trianglePolygon(i);
	    }
	  }
	  trianglePolygon(i) {
	    const polygon = new Polygon;
	    this.renderTriangle(i, polygon);
	    return polygon.value();
	  }
	}

	Delaunay.from = function(points, fx = pointX, fy = pointY, that) {
	  return new Delaunay("length" in points
	      ? flatArray(points, fx, fy, that)
	      : Float64Array.from(flatIterable(points, fx, fy, that)));
	};

	function flatArray(points, fx, fy, that) {
	  const n = points.length;
	  const array = new Float64Array(n * 2);
	  for (let i = 0; i < n; ++i) {
	    const p = points[i];
	    array[i * 2] = fx.call(that, p, i, points);
	    array[i * 2 + 1] = fy.call(that, p, i, points);
	  }
	  return array;
	}

	function* flatIterable(points, fx, fy, that) {
	  let i = 0;
	  for (const p of points) {
	    yield fx.call(that, p, i, points);
	    yield fy.call(that, p, i, points);
	    ++i;
	  }
	}

	class Outlying {
	    constructor(tree, upperBound) {
	        //Clone the tree to avoid modifying it
	        this.tree = JSON.parse(JSON.stringify(tree));
	        this.upperBound = upperBound;
	    }

	    /**
	     * Returns outlying score
	     * @returns {number}
	     */
	    score() {
	        let tree = this.tree,
	            totalLengths = 0,
	            totalOutlyingLengths = 0;
	        let upperBound = this.upperBound;
	        if(!upperBound){
	            let allLengths = tree.links.map(l => l.weight),
	                q1 = quantile(allLengths, 0.25),
	                q3 = quantile(allLengths, 0.75),
	                iqr = q3 - q1;
	            // upperBound = q3+1.5*iqr;
	            upperBound = q3+3*iqr;
	            //Save it for displaying purpose.
	            this.upperBound = upperBound;
	        }
	        tree.links.forEach(l => {
	            totalLengths += l.weight;
	            if (l.weight > upperBound) {
	                totalOutlyingLengths += l.weight;
	                l.isOutlying = true;
	            }
	        });
	        return totalOutlyingLengths / totalLengths;
	    }

	    /**
	     * Returns outlying links
	     */
	    links() {
	        return this.tree.links.filter(l => l.isOutlying);
	    }

	    /**
	     * Remove outlying links and nodes and return a new tree without outlying points/edges
	     */
	    removeOutlying() {
	        var newTree = JSON.parse(JSON.stringify(this.tree));
	        //Remove outlying links
	        newTree.links = newTree.links.filter(l => !l.isOutlying);
	        //Remove outlying nodes (nodes are not in any none-outlying links
	        let allNodesWithLinks = [];
	        newTree.links.forEach(l => {
	            allNodesWithLinks.push(l.source);
	            allNodesWithLinks.push(l.target);
	        });
	        allNodesWithLinks = underscore.uniq(allNodesWithLinks, false, d => d.join(','));
	        //TODO: May need to reuse the existing result instead of calculating all again.
	        //Triangulate again
	        let delaunay = Delaunay.from(allNodesWithLinks);
	        delaunay.points = allNodesWithLinks;
	        delaunay.triangleCoordinates = function(){
	            let triangles = this.triangles;
	            let tc = [];
	            for (let i = 0; i < triangles.length; i += 3) {
	                tc.push([
	                    this.points[triangles[i]],
	                    this.points[triangles[i + 1]],
	                    this.points[triangles[i + 2]]
	                ]);
	            }
	            return tc;
	        };
	        let graph = createGraph(delaunay.triangleCoordinates());
	        newTree = mst(graph);
	        return newTree;
	    }

	    /**
	     * Returns the outlying points (in form of points, not node object).
	     * @returns {Array}
	     */
	    points(){
	        let newTree = this.removeOutlying();
	        let newNodes = newTree.nodes;
	        let oldNodes = this.tree.nodes;
	        let ops = [];
	        oldNodes.forEach(n=>{
	            //.id since we are accessing to points and the node is in form of {id: thePoint}
	            if(!pointExists(newNodes.map(n=>n.id), n.id)){
	                ops.push(n.id);
	            }
	        });
	        return ops;
	    }
	}

	class Skewed {
	    constructor(tree) {
	        //Clone the tree to avoid modifying it
	        this.tree = JSON.parse(JSON.stringify(tree));
	    }

	    /**
	     * Returns skewed score
	     * @returns {number}
	     */
	    score() {
	        let allLengths = this.tree.links.map(l=>l.weight),
	        q90 = quantile(allLengths, .9),
	        q50 = quantile(allLengths, .5),
	        q10 = quantile(allLengths, .1);
	        if(q90!=q10){
	            return (q90-q50)/(q90-q10);
	        }else{
	            return 0;
	        }

	    }
	}

	class Sparse {
	    constructor(tree) {
	        //Clone the tree to avoid modifying it
	        this.tree = JSON.parse(JSON.stringify(tree));
	    }

	    /**
	     * Returns sparse score
	     * @returns {number}
	     */
	    score() {
	        let allLengths = this.tree.links.map(l=>l.weight),
	            q90 = quantile(allLengths, .9);
	        return q90;
	    }
	}

	class Striated {
	    constructor(tree) {
	        //Clone the tree to avoid modifying it
	        this.tree = JSON.parse(JSON.stringify(tree));
	    }

	    /**
	     * Returns striated score
	     * @returns {number}
	     */
	    score() {
	        //Loop through the nodes.
	        let verticesCount = this.tree.nodes.length;
	        let allObtuseV2CornersCount = this.getAllObtuseV2Corners().length;
	        return allObtuseV2CornersCount / verticesCount;
	    }

	    getAllObtuseV2Corners() {
	        let allV2Corners = this.getAllV2Corners();
	        let allObtuseV2Corners = [];
	        allV2Corners.forEach(corner => {
	            let cs = cosine(corner[0], corner[1], corner[2]);
	            if (cs < -.75) {
	                allObtuseV2Corners.push(corner);
	            }
	        });
	        return allObtuseV2Corners;

	        function cosine(p1, p2, p3) {
	            let p12 = distance(p1, p2),
	                p13 = distance(p1, p3),
	                p23 = distance(p2, p3);
	            return ((Math.pow(p12, 2)) + (Math.pow(p13, 2)) - (Math.pow(p23, 2))) / (2 * p12 * p13);
	        }
	    }

	    /**
	     * This function returns corners (three vertices) of vertices of degree two in the for mat of
	     * point1, point2, point3 => point1 is the the vertex with degree two (two edges connected to it are [point1, point2] and [point1, point3] (order of the points in each edge is not important)).
	     */
	    getAllV2Corners() {
	        return getAllV2CornersFromTree(this.tree);
	    }
	}

	function area(polygon) {
	  var i = -1,
	      n = polygon.length,
	      a,
	      b = polygon[n - 1],
	      area = 0;

	  while (++i < n) {
	    a = b;
	    b = polygon[i];
	    area += a[1] * b[0] - a[0] * b[1];
	  }

	  return area / 2;
	}

	// Returns the 2D cross product of AB and AC vectors, i.e., the z-component of

	function contains(polygon, point) {
	  var n = polygon.length,
	      p = polygon[n - 1],
	      x = point[0], y = point[1],
	      x0 = p[0], y0 = p[1],
	      x1, y1,
	      inside = false;

	  for (var i = 0; i < n; ++i) {
	    p = polygon[i], x1 = p[0], y1 = p[1];
	    if (((y1 > y) !== (y0 > y)) && (x < (x0 - x1) * (y - y1) / (y0 - y1) + x1)) inside = !inside;
	    x0 = x1, y0 = y1;
	  }

	  return inside;
	}

	function length(polygon) {
	  var i = -1,
	      n = polygon.length,
	      b = polygon[n - 1],
	      xa,
	      ya,
	      xb = b[0],
	      yb = b[1],
	      perimeter = 0;

	  while (++i < n) {
	    xa = xb;
	    ya = yb;
	    b = polygon[i];
	    xb = b[0];
	    yb = b[1];
	    xa -= xb;
	    ya -= yb;
	    perimeter += Math.sqrt(xa * xa + ya * ya);
	  }

	  return perimeter;
	}

	class ConcaveHull{
	    constructor(distance$$1){
	        if(!distance$$1){
	            this.calculateDistance = this.stdevDistance;
	        }
	        else if(typeof distance$$1 === "function"){
	            this.calculateDistance = distance$$1;
	        }else if(typeof distance$$1 === "number"){
	            this.calculateDistance = function () {return distance$$1;};
	        }
	        this.padding = 0;
	    }
	    coveringConcaveHull(delaunay){
	        let theMst = mst(createGraph(delaunay));
	        let allLengths = theMst.links.map(l=>l.weight);
	        let allPoints = theMst.nodes.map(n=>n.id);
	        //We will start with q7
	        let qx = 0.5,
	            increment = 0.01;
	        let theHull = null;
	        do{
	            qx = qx + increment;
	            let longEdge = quantile(allLengths, qx);
	            theHull = this.concaveHull(delaunay, longEdge);
	        }while(!coverAllPoints(theHull, allPoints));

	        return theHull;

	        function coverAllPoints(hull$$1, points) {
	            for (let i = 0; i < points.length; i++) {
	                let point = points[i];
	                let pointIsCovered = false;
	                for (let j = 0; j < hull$$1.length; j++) {
	                    if(contains(hull$$1[j], point)){
	                        pointIsCovered = true;
	                        break;
	                    }
	                }
	                if(!pointIsCovered){
	                    return false;
	                }
	            }
	            return true;
	        }
	    }
	    /**
	     * generate the concave hull.
	     * @param delaunay is inform of coordinates of triangulated triangles (3 points per triangle)
	     * @returns {Array}
	     */
	    concaveHull(delaunay, longEdge) {
	        if(!longEdge){
	            longEdge = this.calculateDistance(delaunay);
	        }
	        let mesh = delaunay.filter(function (d) {
	            return distance(d[0], d[1]) < longEdge && distance(d[0], d[2]) < longEdge && distance(d[1], d[2]) < longEdge
	        });

	        var counts = {},
	            edges = {},
	            r,
	            result = [];
	        // Traverse the edges of all triangles and discard any edges that appear twice.
	        mesh.forEach(function (triangle) {
	            for (var i = 0; i < 3; i++) {
	                var edge = [triangle[i], triangle[(i + 1) % 3]].sort(ascendingCoords).map(String);
	                (edges[edge[0]] = (edges[edge[0]] || [])).push(edge[1]);
	                (edges[edge[1]] = (edges[edge[1]] || [])).push(edge[0]);
	                var k = edge.join(":");
	                if (counts[k]) delete counts[k];
	                else counts[k] = 1;
	            }
	        });

	        while (1) {
	            var k = null;
	            // Pick an arbitrary starting point on a boundary.
	            for (k in counts) break;
	            if (k == null) break;
	            result.push(r = k.split(":").map(function (d) {
	                return d.split(",").map(Number);
	            }));
	            delete counts[k];
	            var q = r[1];
	            while (q[0] !== r[0][0] || q[1] !== r[0][1]) {
	                var p = q,
	                    qs = edges[p.join(",")],
	                    n = qs.length;
	                for (var i = 0; i < n; i++) {
	                    q = qs[i].split(",").map(Number);
	                    var edge = [p, q].sort(ascendingCoords).join(":");
	                    if (counts[edge]) {
	                        delete counts[edge];
	                        r.push(q);
	                        break;
	                    }
	                }
	            }
	        }

	        if (this.padding !== 0) {
	            result = pad(result, this.padding);
	        }

	        return result;

	        function pad(bounds, amount) {
	            var result = [];
	            bounds.forEach(function (bound) {
	                var padded = [];

	                var area$$1 = 0;
	                bound.forEach(function (p, i) {
	                    // http://forums.esri.com/Thread.asp?c=2&f=1718&t=174277
	                    // Area = Area + (X2 - X1) * (Y2 + Y1) / 2

	                    var im1 = i - 1;
	                    if (i == 0) {
	                        im1 = bound.length - 1;
	                    }
	                    var pm = bound[im1];
	                    area$$1 += (p[0] - pm[0]) * (p[1] + pm[1]) / 2;
	                });
	                var handedness = 1;
	                if (area$$1 > 0) handedness = -1;
	                bound.forEach(function (p, i) {
	                    // average the tangent between
	                    var im1 = i - 1;
	                    if (i == 0) {
	                        im1 = bound.length - 2;
	                    }
	                    //var tp = getTangent(p, bound[ip1]);
	                    var tm = getTangent(p, bound[im1]);
	                    //var avg = { x: (tp.x + tm.x)/2, y: (tp.y + tm.y)/2 };
	                    //var normal = rotate2d(avg, 90);
	                    var normal = rotate2d(tm, 90 * handedness);
	                    padded.push([p[0] + normal.x * amount, p[1] + normal.y * amount]);
	                });
	                result.push(padded);
	            });
	            return result
	        }

	        function getTangent(a, b) {
	            var vector = {x: b[0] - a[0], y: b[1] - a[1]};
	            var magnitude = Math.sqrt(vector.x * vector.x + vector.y * vector.y);
	            vector.x /= magnitude;
	            vector.y /= magnitude;
	            return vector
	        }

	        function rotate2d(vector, angle) {
	            //rotate a vector
	            angle *= Math.PI / 180; //convert to radians
	            return {
	                x: vector.x * Math.cos(angle) - vector.y * Math.sin(angle),
	                y: vector.x * Math.sin(angle) + vector.y * Math.cos(angle)
	            }
	        }

	        function ascendingCoords(a, b) {
	            return a[0] === b[0] ? b[1] - a[1] : b[0] - a[0];
	        }
	    }
	    stdevDistance(delaunay) {
	        var sides = [];
	        delaunay.forEach(function (d) {
	            sides.push(distance(d[0], d[1]));
	            sides.push(distance(d[0], d[2]));
	            sides.push(distance(d[1], d[2]));
	        });

	        var dev = d3.deviation(sides);
	        var mean$$1 = d3.mean(sides);

	        return mean$$1 + dev;
	    }
	}
	function concaveHullArea(concaveHull) {
	    let concaveArea = 0;
	    concaveHull.forEach(hull$$1 => {
	        let area$$1 = area(hull$$1);
	        concaveArea += area$$1>0?area$$1:-area$$1;
	    });
	    return concaveArea;
	}
	function concaveHullLength(concaveHull) {
	    let concaveLength = 0;
	    concaveHull.forEach(hull$$1 => {
	        concaveLength += length(hull$$1);
	    });
	    return concaveLength;
	}

	class Convex {
	    constructor(tree) {
	        //Clone the tree to avoid modifying it
	        this.tree = JSON.parse(JSON.stringify(tree));
	        let sites = this.tree.nodes.map(d => d.id);
	        this.delaunay = Delaunay.from(sites);
	        this.delaunay.points = sites;
	        this.delaunay.triangleCoordinates = function(){
	            let triangles = this.triangles;
	            let tc = [];
	            for (let i = 0; i < triangles.length; i += 3) {
	                tc.push([
	                    this.points[triangles[i]],
	                    this.points[triangles[i + 1]],
	                    this.points[triangles[i + 2]]
	                ]);
	            }
	            return tc;
	        };
	    }
	    /**
	     * Returns convex score
	     * @returns {number}
	     */
	    score() {
	        let concaveArea = concaveHullArea(this.concaveHull());
	        return concaveArea/area(this.convexHull());
	    }
	    noOutlyingTriangleCoordinates(){

	        return this.delaunay.triangleCoordinates();
	    }
	    concaveHull() {
	        //Use quantile as cutoff values.
	        let allLengths = this.tree.links.map(l => l.weight),
	            concaveHull = new ConcaveHull(quantile(allLengths, 0.999)).concaveHull(this.noOutlyingTriangleCoordinates());
	            // concaveHull = new ConcaveHull().coveringConcaveHull(this.noOutlyingTriangleCoordinates());
	        return concaveHull;
	    }
	    convexHull() {
	        let hull$$1 = this.delaunay.hull;
	        let convexHull = [];
	        let e = hull$$1;
	        do {
	            convexHull.push([e.x, e.y]);
	            e = e.next;
	        } while (e != hull$$1);
	        return convexHull;
	    }
	}

	class Skinny {
	    constructor(alphaHull) {
	        //Clone it in order to avoid modifying it.
	        this.alphaHull = alphaHull.slice(0);
	    }
	    /**
	     * Returns skinny score
	     * @returns {number}
	     */
	    score() {
	        return 1 - Math.sqrt(4*Math.PI*concaveHullArea(this.alphaHull))/concaveHullLength(this.alphaHull);
	    }
	}

	class Stringy {
	    constructor(tree) {
	        //Clone the tree to avoid modifying it
	        this.tree = JSON.parse(JSON.stringify(tree));
	    }

	    /**
	     * Returns striated score
	     * @returns {number}
	     */
	    score() {
	        //Loop through the nodes.
	        let verticesCount = this.tree.nodes.length;
	        let v2Count = this.getAllV2Corners().length;
	        let v1Count = this.getAllV1s().length;
	        return v2Count/(verticesCount-v1Count);
	    }

	    /**
	     * This function returns corners (three vertices) of vertices of degree two in the for mat of
	     * point1, point2, point3 => point1 is the the vertex with degree two (two edges connected to it are [point1, point2] and [point1, point3] (order of the points in each edge is not important)).
	     * @returns {Array}
	     */
	    getAllV2Corners(){
	        return getAllV2CornersFromTree(this.tree);
	    }

	    /**
	     * This function returns
	     * @returns {Array}
	     */
	    getAllV1s(){
	        return getAllV1sFromTree(this.tree);
	    }
	}

	class Monotonic {
	    constructor(points) {
	        //Clone it in order to avoid modifying it.
	        this.points = points.slice(0);
	    }
	    /**
	     * Returns monotonic score
	     * @returns {number}
	     */
	    score() {
	        let xArr = [];
	        let yArr = [];
	        this.points.forEach(p=>{
	            xArr.push(p[0]);
	            yArr.push(p[1]);
	        });
	        let r = computeSpearmans(xArr, yArr);
	        return Math.pow(r, 2);

	        /**Adopted from: https://bl.ocks.org/nkullman/f65d5619843dc22e061d957249121408**/
	        function computeSpearmans(arrX, arrY) {
	            // simple error handling for input arrays of nonequal lengths
	            if (arrX.length !== arrY.length) { return null; }

	            // number of observations
	            let n = arrX.length;

	            // rank datasets
	            let xRanked = rankArray(arrX),
	                yRanked = rankArray(arrY);

	            // sum of distances between ranks
	            let dsq = 0;
	            for (let i = 0; i < n; i++) {
	                dsq += Math.pow(xRanked[i] - yRanked[i], 2);
	            }

	            // compute correction for ties
	            let xTies = countTies(arrX),
	                yTies = countTies(arrY);
	            let xCorrection = 0,
	                yCorrection = 0;
	            for (let tieLength in xTies) {
	                xCorrection += xTies[tieLength] * tieLength * (Math.pow(tieLength, 2) - 1);
	            }
	            xCorrection /= 12.0;
	            for (let tieLength in yTies) {
	                yCorrection += yTies[tieLength] * tieLength * (Math.pow(tieLength, 2) - 1);
	            }
	            yCorrection /= 12.0;

	            // denominator
	            let denominator = n * (Math.pow(n, 2) - 1) / 6.0;

	            // compute rho
	            let rho = denominator - dsq - xCorrection - yCorrection;
	            rho /= Math.sqrt((denominator - 2 * xCorrection) * (denominator - 2 * yCorrection));

	            return rho;
	        }
	        /** Computes the rank array for arr, where each entry in arr is
	         * assigned a value 1 thru n, where n is arr.length.
	         *
	         * Tied entries in arr are each given the average rank of the ties.
	         * Lower ranks are not increased
	         */
	        function rankArray(arr) {

	            // ranking without averaging
	            let sorted = arr.slice().sort(function (a, b) { return b - a });
	            let ranks = arr.slice().map(function (v) { return sorted.indexOf(v) + 1 });

	            // counts of each rank
	            let counts = {};
	            ranks.forEach(function (x) { counts[x] = (counts[x] || 0) + 1; });

	            // average duplicates
	            ranks = ranks.map(function (x) { return x + 0.5 * ((counts[x] || 0) - 1); });

	            return ranks;
	        }
	        /** Counts the number of ties in arr, and returns
	         * an object with
	         * a key for each tie length (an entry n for each n-way tie) and
	         * a value corresponding to the number of key-way (n-way) ties
	         */
	         function countTies(arr) {
	            let ties = {},
	                arrSorted = arr.slice().sort(),
	                currValue = arrSorted[0],
	                tieLength = 1;

	            for (let i = 1; i < arrSorted.length; i++) {
	                if (arrSorted[i] === currValue) {
	                    tieLength++;
	                } else {
	                    if (tieLength > 1) {
	                        if (ties[tieLength] === undefined) ties[tieLength] = 0;
	                        ties[tieLength]++;
	                    }
	                    currValue = arrSorted[i];
	                    tieLength = 1;
	                }
	            }
	            if (tieLength > 1) {
	                if (ties[tieLength] === undefined) ties[tieLength] = 0;
	                ties[tieLength]++;
	            }
	            return ties;
	        }
	    }
	}

	class Normalizer {
	    constructor(points) {
	        this.points = points.slice(0);
	        let [xArr, yArr] = [this.xArr, this.yArr] = underscore.unzip(this.points),
	            maxX = this.maxX = underscore.max(xArr),
	            minX = this.minX = underscore.min(xArr),
	            maxY = this.maxY = underscore.max(yArr),
	            minY = this.minY = underscore.min(yArr),
	            rangeX = this.rangeX = (maxX!=minX) ? maxX - minX: 1,
	            rangeY = this.rangeY = (maxY!=minY) ? maxY - minY: 1,
	            normalizedXArr = this.normalizedXArr = xArr.map(x => (x - minX) / rangeX),
	            normalizedYArr = this.normalizedYArr = yArr.map(y => (y - minY) / rangeY);
	        this.normalizedPoints = underscore.zip(normalizedXArr, normalizedYArr);
	        //Add one step to pass the data over if there is.
	        let length = this.points.length;
	        for (let i = 0; i < length; i++) {
	            this.normalizedPoints[i].data = this.points[i].data;
	        }
	    }

	    /**
	     * Input a set of points in this scale range [0, 1] and will be scaled back to
	     * - Original scale ([minX, maxX], [minY, maxY])
	     * @param points
	     */
	    scaleBackPoints(points) {
	        return points.map(point=>{
	            return this.scaleBackPoint(point);
	        });
	    }
	    /**
	     * Input a single point in this scale range [0, 1] and will be scaled back to
	     * - Original scale ([minX, maxX], [minY, maxY])
	     * @param points
	     */
	    scaleBackPoint(point) {
	        let xs = point[0],
	            x = this.rangeX * xs + this.minX,
	            ys = point[1],
	            y = this.rangeY * ys + this.minY;
	        return [x, y];
	    }
	}

	class LeaderBinner{
	    constructor(points, radius){
	        //TODO: Should check if there are more than 3 unique values here or even after the binning.
	        //TODO: May need to clone the points to avoid modifying it, but we don't do to reserve other data or to make the process faster
	        // //Clone these to avoid modifying them
	        // this.points = points.map(p=>p.slice(0));
	        this.points = points;
	        this.radius = radius;
	    }
	    get leaders(){
	        let self = this;
	        let theLeaders = [];
	        //find all the leaders
	        this.points.forEach(point=>{
	            let leader = closestLeader(theLeaders, point);
	            if(!leader){
	                let newLeader = [];
	                newLeader.x = point[0];
	                newLeader.y = point[1];
	                theLeaders.push(newLeader);
	            }
	        });
	        //now do this again to set the closest leader.
	        this.points.forEach(point=>{
	           let leader = closestLeader(theLeaders, point);
	           leader.push(point);
	        });
	        return theLeaders;
	        function closestLeader(leaders, point){
	            let length = leaders.length;
	            let minDistance = 2;//select 2 since normalized distance can't  be greater than 2.
	            let theLeader = null;
	            for (let i = 0; i < length; ++i) {
	                let l = leaders[i];
	                let d = distance([l.x, l.y], point);
	                if(d< self.radius){
	                    if(d<minDistance){
	                        minDistance = d;
	                        theLeader = l;
	                    }
	                }
	            }
	            return theLeader;

	            // let distances = leaders.map(l=>distance([l.x, l.y], point));
	            // //Filter the distance to be <= the radius
	            // let copiedDistances = distances.filter(d=>d<self.radius);
	            // if(copiedDistances.length===0){
	            //     return null;
	            // }
	            // let theDistance = _.min(distances);
	            // let theLeader = leaders[distances.indexOf(theDistance)];
	            // return theLeader;
	        }
	    }
	}

	//Inspired from https://github.com/d3/d3-hexbin/blob/master/src/hexbin.js
	function Binner(){
	    let thirdPi = Math.PI/3,
	    angles = [0, thirdPi, 2*thirdPi, 3*thirdPi, 4*thirdPi, 5*thirdPi];

	    function pointX(d){
	        return d[0];
	    }
	    function pointY(d){
	        return d[1];
	    }

	    var x0 = 0,
	        y0 = 0,
	        x1 = 1,
	        y1 = 1,
	        x = pointX,
	        y = pointY,
	        r,
	        dx,
	        dy;

	    function hexbin(points){
	        var binsById = {}, bins = [], i, n = points.length;

	        for (i = 0; i < n; ++i) {
	            if (isNaN(px = +x.call(null, point = points[i], i, points))
	                || isNaN(py = +y.call(null, point, i, points))) continue;

	            var point,
	                px,
	                py,
	                pj = Math.round(py = py / dy),
	                pi = Math.round(px = px / dx - (pj & 1) / 2),
	                py1 = py - pj;

	            if (Math.abs(py1) * 3 > 1) {
	                var px1 = px - pi,
	                    pi2 = pi + (px < pi ? -1 : 1) / 2,
	                    pj2 = pj + (py < pj ? -1 : 1),
	                    px2 = px - pi2,
	                    py2 = py - pj2;
	                if (px1 * px1 + py1 * py1 > px2 * px2 + py2 * py2) pi = pi2 + (pj & 1 ? 1 : -1) / 2, pj = pj2;
	            }

	            var id = pi + "-" + pj, bin = binsById[id];
	            if (bin) bin.push(point);
	            else {
	                bins.push(bin = binsById[id] = [point]);
	                bin.x = (pi + (pj & 1) / 2) * dx;
	                bin.y = pj * dy;
	                //TODO: fix this since there are results with bin.x, bin.y > 1 => we may need to do the rounding.
	                // if(bin.x>1){bin.x = 1;}
	                // if(bin.y>1){bin.y =1;}
	            }
	        }

	        return bins;
	    }
	    function hexagon(radius){
	        var x0 = 0, y0 = 0;
	        return angles.map(function(angle) {
	            var x1 = Math.sin(angle) * radius,
	                y1 = -Math.cos(angle) * radius,
	                dx = x1 - x0,
	                dy = y1 - y0;
	            x0 = x1, y0 = y1;

	            return [dx, dy];
	        });
	    }

	    //Export it
	    this.hexbin = hexbin;
	    this.hexagon = function(radius){
	        return "m" + hexagon(radius == null ? r : +radius).join("l") + "z";
	    };
	    this.centers = function(){
	        var centers = [],
	            j = Math.round(y0 / dy),
	            i = Math.round(x0 / dx);
	        for (var y = j * dy; y < y1 + r; y += dy, ++j) {
	            for (var x = i * dx + (j & 1) * dx / 2; x < x1 + dx / 2; x += dx) {
	                centers.push([x, y]);
	            }
	        }
	        return centers;
	    };
	    this.mesh = function(){
	        var fragment = hexagon(r).slice(0, 4).join("l");
	        return hexbin.centers().map(function(p) { return "M" + p + "m" + fragment; }).join("");
	    };
	    //Setters/getters
	    this.x = function(_){
	        return arguments.length ? (x = _, this) : x;
	    };
	    this.y = function(_){
	        return arguments.length ? (y = _, this) : y;
	    };
	    this.radius = function(_){
	        return arguments.length ? (r= +_, dx = r * 2 * Math.sin(thirdPi), dy = r*1.5, this): r;
	    };
	    this.size = function(_) {
	        return arguments.length ? (x0 = y0 = 0, x1 = +_[0], y1 = +_[1], this) : [x1 - x0, y1 - y0];
	    };
	    this.extent = function(_){
	        return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], this): [[x0, y0], [x1, y1]];
	    };

	    return this.radius(1);
	}

	(function(window){
	    /**
	     * initialize a scagnostic object
	     * @param inputPoints   {*[][]} set of points from the scatter plot
	     * @returns {*[][]}
	     */
	    window.scagnostics = function(inputPoints, binType,startBinGridSize, isNormalized, isBinned, outlyingUpperBound, minBins, maxBins) {
	        //Clone it to avoid modifying it.
	        let points = inputPoints.slice(0);
	        let normalizedPoints = points;
	        /******This section is about normalizing the data******/
	        if(!isNormalized){
	            let normalizer = new Normalizer(points);
	            normalizedPoints = normalizer.normalizedPoints;
	        }
	        outputValue("normalizedPoints", normalizedPoints);
	        /******This section is about finding number of bins and binners******/
	        let sites = null;
	        let bins = null;
	        let binner = null;
	        let binSize = null;
	        let binRadius = 0;

	        if(!isBinned){//Only do the binning if needed.
	            if(!startBinGridSize){
	                startBinGridSize = 40;
	            }
	            bins = [];
	            //Default number of bins
	            let minNumOfBins = 50;
	            let maxNumOfBins = 250;
	            if(minBins){
	                minNumOfBins =minBins;
	            }
	            if(maxBins){
	                maxNumOfBins = maxBins;
	            }
	            //Don't do the binning if the unique set of values are less than 50. Just return the unique set.
	            let uniqueKeys = underscore.uniq(normalizedPoints.map(p=>p.join(',')));
	            let groups = underscore.groupBy(normalizedPoints, p=>p.join(','));
	            if(uniqueKeys.length<minNumOfBins){
	                uniqueKeys.forEach(key=>{
	                    let bin = groups[key];
	                    //Take the coordinate of the first point in the group to be the bin leader (they should have the same points actually=> so just take the first one.
	                    bin.x = bin[0][0];
	                    bin.y = bin[0][1];
	                    bin.binRadius = 0;
	                    bins.push(bin);
	                });
	            }else{
	                do{
	                    //Start with 40x40 bins, and divided by 2 every time there are more than maxNumberofBins none empty cells, increase 5 (+5) if less than minNumberOfBins
	                    if(binSize===null){
	                        binSize = startBinGridSize;
	                    }else if(bins.length>maxNumOfBins){
	                        binSize = binSize/2;
	                    }else if(bins.length<minNumOfBins){
	                        binSize = binSize + 5;
	                    }
	                    if(binType==="hexagon"){
	                        // This section uses hexagon binning
	                        let shortDiagonal = 1/binSize;
	                        binRadius = Math.sqrt(3)*shortDiagonal/2;
	                        binner = new Binner().radius(binRadius).extent([[0, 0], [1, 1]]);//extent from [0, 0] to [1, 1] since we already normalized data.
	                        bins = binner.hexbin(normalizedPoints);
	                    }else if(!binType || binType==="leader"){
	                        // This section uses leader binner
	                        binRadius = 1/(binSize*2);
	                        binner = new LeaderBinner(normalizedPoints, binRadius);
	                        bins = binner.leaders;
	                    }
	                }while(bins.length > maxNumOfBins || bins.length < minNumOfBins);
	            }
	            sites = bins.map(d => [d.x, d.y]); //=>sites are the set of centers of all bins
	            /******This section is about the binning and binning results******/
	            outputValue("binner", binner);
	            outputValue("bins", bins);
	            outputValue("binSize", binSize);
	            outputValue("binRadius", binRadius);
	        }else{
	            sites = normalizedPoints;
	        }

	        outputValue("binnedSites", sites);

	        /******This section is about the triangulating and triangulating results******/
	        //Triangulation calculation
	        let delaunay = Delaunay.from(sites);
	        //TODO: There are many placed we need the triangleCoordinates function => we should build it as a prototype instead of copy/paste this function in many different places.
	        delaunay.points = sites;
	        let triangles = delaunay.triangles;
	        delaunay.triangleCoordinates = function(){
	            let triangles = this.triangles;
	            let tc = [];
	            for (let i = 0; i < triangles.length; i += 3) {
	                tc.push([
	                    this.points[triangles[i]],
	                    this.points[triangles[i + 1]],
	                    this.points[triangles[i + 2]]
	                ]);
	            }
	            return tc;
	        };
	        let triangleCoordinates = delaunay.triangleCoordinates();
	        //Assigning output values
	        outputValue("delaunay", delaunay);
	        outputValue("triangles", triangles);
	        outputValue("triangleCoordinates", triangleCoordinates);

	        /******This section is about the spanning tree and spanning tree results******/
	        //Spanning tree calculation
	        let graph = createGraph(triangleCoordinates);
	        let mstree = mst(graph);
	        //Assigning the output values
	        outputValue("graph", graph);
	        outputValue("mst", mstree);

	        /******This section is about the outlying score and outlying score results******/
	        let outlying = new Outlying(mstree);
	        let outlyingScore = outlying.score();
	            outlyingUpperBound = outlying.upperBound;
	        let outlyingLinks = outlying.links();
	        let outlyingPoints = outlying.points();
	        let noOutlyingTree = outlying.removeOutlying();
	        outputValue("outlyingScore", outlyingScore);
	        outputValue("outlyingUpperBound", outlyingUpperBound);
	        outputValue("outlyingLinks", outlyingLinks);
	        outputValue("outlyingPoints", outlyingPoints);
	        outputValue("noOutlyingTree", noOutlyingTree);

	        /******This section is about the skewed score and skewed score results******/
	        let skewed = new Skewed(noOutlyingTree);
	        outputValue("skewedScore", skewed.score());

	        /******This section is about the sparse score and sparse score results******/
	        let sparse = new Sparse(noOutlyingTree);
	        outputValue("sparseScore", sparse.score());

	        /******This section is about the clumpy score and clumpy score results******/
	        let clumpy = new Clumpy(noOutlyingTree);
	        outputValue("clumpy", clumpy);
	        outputValue("clumpyScore", clumpy.score());

	        /******This section is about the striated score and striated score results******/
	        let striated = new Striated(noOutlyingTree);
	        let v2Corners = striated.getAllV2Corners();
	        let obtuseV2Corners = striated.getAllObtuseV2Corners();
	        outputValue("striatedScore", striated.score());
	        outputValue("v2Corners", v2Corners);
	        outputValue("obtuseV2Corners", obtuseV2Corners);

	        /******This section is about the convex hull and convex hull results******/
	        let convex = new Convex(noOutlyingTree);
	        let convexHull = convex.convexHull();
	        let noOutlyingTriangleCoordinates = convex.noOutlyingTriangleCoordinates();
	        outputValue("noOutlyingTriangleCoordinates", noOutlyingTriangleCoordinates);
	        outputValue("convexHull", convexHull);

	        /******This section is about the concave hull and concave hull results******/
	        let concaveHull = convex.concaveHull();
	        outputValue("concaveHull", concaveHull);

	        /******This section is about the convex score and convex score results******/
	        let convexScore = convex.score();
	        outputValue("convexScore", convexScore);

	        /******This section is about the skinny score and skinny score results******/
	        let skinny = new Skinny(concaveHull);
	        let skinnyScore = skinny.score();
	        outputValue("skinnyScore", skinnyScore);

	        /******This section is about the stringy score and stringy score results******/
	        let stringy = new Stringy(noOutlyingTree);
	        let v1s = stringy.getAllV1s();
	        let stringyScore = stringy.score();
	        outputValue("v1s", v1s);
	        outputValue("stringyScore", stringyScore);

	        /******This section is about the monotonic score and monotonic score results******/
	        let monotonic = new Monotonic(noOutlyingTree.nodes.map(n=>n.id));
	        let monotonicScore = monotonic.score();
	        outputValue("monotonicScore", monotonicScore);

	        return window.scagnostics;
	        function outputValue(name, value){
	            window.scagnostics[name] = value;
	        }
	    };

	})(window);

}());