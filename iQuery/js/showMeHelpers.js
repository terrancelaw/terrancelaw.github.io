const ShowMeHelpers = {

	// density plot template

	isCurrentSpecMatchesDensityPlotTemplate: function() {
		const self = this;
		let areAllOtherShelvesEmpty = self.checkAreAllOtherShelvesEmpty();
		let isXYAxisOccupiedByDistributionVar = self.checkIsXYAxisOccupiedByDistributionAttr();
		let isColorRowColShelvesEmptyOrOccupiedBySplitAttr = self.checkIsColorRowColShelvesEmptyOrOccupiedBySplitAttr();

		return areAllOtherShelvesEmpty && isXYAxisOccupiedByDistributionVar && isColorRowColShelvesEmptyOrOccupiedBySplitAttr;
	},
	checkAreAllOtherShelvesEmpty: function() {
		let isSizeShelfEmpty = Shelf.size.isEmpty();
		let isShapeShelfEmpty = Shelf.shape.isEmpty();
		let isTooltipShelfEmpty = Shelf.tooltip.isEmpty();

		return (isSizeShelfEmpty && isShapeShelfEmpty && isTooltipShelfEmpty);
	},
	checkIsXYAxisOccupiedByDistributionAttr: function() {
		let isXAxisShelfEmpty = Shelf.xAxis.isEmpty();
		let isYAxisShelfEmpty = Shelf.yAxis.isEmpty();

		let xAxisShelfData = Shelf.xAxis.getCapsuleData();
		let yAxisShelfData = Shelf.yAxis.getCapsuleData();

		let isXAxisShelfNumberOfRecords = !isXAxisShelfEmpty && xAxisShelfData.attributeName == 'Number of Records' && xAxisShelfData.isAutoGenerated;
		let isYAxisShelfNumberOfRecords = !isYAxisShelfEmpty && yAxisShelfData.attributeName == 'Number of Records' && yAxisShelfData.isAutoGenerated;
		let isXAxisShelfQuantitative = !isXAxisShelfEmpty && !isXAxisShelfNumberOfRecords && xAxisShelfData.type == 'quantitative' && xAxisShelfData.aggregate == 'none';
		let isYAxisShelfQuantitative = !isYAxisShelfEmpty && !isYAxisShelfNumberOfRecords && yAxisShelfData.type == 'quantitative' && yAxisShelfData.aggregate == 'none';

		return (isXAxisShelfQuantitative && (isYAxisShelfNumberOfRecords || isYAxisShelfEmpty)) ||
			   (isYAxisShelfQuantitative && (isXAxisShelfNumberOfRecords || isXAxisShelfEmpty));
	},
	checkIsColorRowColShelvesEmptyOrOccupiedBySplitAttr: function() {
		let isColourShelfEmpty = Shelf.colour.isEmpty();
		let isRowShelfEmpty = Shelf.row.isEmpty();
		let isColumnShelfEmpty = Shelf.column.isEmpty();

		let colourShelfData = Shelf.colour.getCapsuleData();
		let rowShelfData = Shelf.row.getCapsuleData();
		let columnShelfData = Shelf.column.getCapsuleData();

		let isColourShelfSplitAttr = !isColourShelfEmpty && 
									 ((colourShelfData.type == 'ordinal' || colourShelfData.type == 'nominal' || colourShelfData.type == 'temporal') ||
									  (colourShelfData.type == 'quantitative' && colourShelfData.aggregate == 'bin')); // temporal will be binned
		let isRowShelfSplitAttr = !isRowShelfEmpty && 
								  (rowShelfData.type == 'ordinal' || rowShelfData.type == 'nominal' || // quantitative and temporal will be binned
								   rowShelfData.type == 'quantitative' ||  rowShelfData.type == 'temporal'); 
		let isColumnShelfSplitAttr = !isColumnShelfEmpty && 
									 (columnShelfData.type == 'ordinal' || columnShelfData.type == 'nominal' || // quantitative and temporal will be binned
									  columnShelfData.type == 'quantitative' || columnShelfData.type == 'temporal'); 

		return (isColourShelfEmpty || isColourShelfSplitAttr) && 
			   (isRowShelfEmpty || isRowShelfSplitAttr) && 
			   (isColumnShelfEmpty || isColumnShelfSplitAttr);
	},

	// density plot loose matching

	areChosenAttrSatifyDensityPlotReq: function() {
		const self = this;
		let allSelectedAttributes = DimensionMeasurePaneCapsules.getSelectedCapsuleData();
		let allAttributesOnShelves = Shelves.getOccupiedShelfCapsuleData();
		let allChosenAttributes = allSelectedAttributes.concat(allAttributesOnShelves);
		let attributesByType = self.getAttributeByType(allChosenAttributes);
		let chosenAttrHasOneQuant = (attributesByType.quantitative.length == 1) && 
									(attributesByType.temporal.length == 0) &&
									(attributesByType.nominal.length == 0) &&
									(attributesByType.ordinal.length == 0) &&
									(attributesByType.otherNotAllowed.length == 0);
		let chosenAttrHasOneQuantAndNominal = (attributesByType.quantitative.length == 1) && 
											  (attributesByType.nominal.length == 1) &&
											  (attributesByType.temporal.length == 0) &&
											  (attributesByType.ordinal.length == 0) &&
											  (attributesByType.otherNotAllowed.length == 0);

		return (chosenAttrHasOneQuant || chosenAttrHasOneQuantAndNominal);
	},

	// density plot adjust specification

	adjustSpecForDensityPlot: function() {
		const self = this;
		let allSelectedAttributes = DimensionMeasurePaneCapsules.getSelectedCapsuleData();
		let allAttributesOnShelves = Shelves.getOccupiedShelfCapsuleData();
		let allChosenAttributes = allSelectedAttributes.concat(allAttributesOnShelves);
		let attributesByType = self.getAttributeByType(allChosenAttributes);
		let chosenAttrHasOneQuant = (attributesByType.quantitative.length == 1) && 
									(attributesByType.temporal.length == 0) &&
									(attributesByType.nominal.length == 0) &&
									(attributesByType.ordinal.length == 0) &&
									(attributesByType.otherNotAllowed.length == 0);
		let chosenAttrHasOneQuantAndNominal = (attributesByType.quantitative.length == 1) && 
											  (attributesByType.nominal.length == 1) &&
											  (attributesByType.temporal.length == 0) &&
											  (attributesByType.ordinal.length == 0) &&
											  (attributesByType.otherNotAllowed.length == 0);

		if (chosenAttrHasOneQuant) {
			let xAttribute = attributesByType.quantitative[0];
			Shelves.emptyAll();
			DimensionMeasurePaneCapsules.clearAllSelection();
			self.addToShelf(xAttribute, 'xAxis');
		}

		if (chosenAttrHasOneQuantAndNominal) {
			let xAttribute = attributesByType.quantitative[0];
			let colourAttribute = attributesByType.nominal[0];
			Shelves.emptyAll();
			DimensionMeasurePaneCapsules.clearAllSelection();
			self.addToShelf(xAttribute, 'xAxis');
			self.addToShelf(colourAttribute, 'colour');
		}
	},

	// trend line template

	isCurrentSpecMatchesTrendLineTemplate: function() {
		const self = this;
		let isScatterplot = self.checkIsScatterPlot();

		return isScatterplot;
	},
	checkIsScatterPlot: function() {
		let isXAxisShelfEmpty = Shelf.xAxis.isEmpty();
		let isYAxisShelfEmpty = Shelf.yAxis.isEmpty();

		let xAxisShelfData = Shelf.xAxis.getCapsuleData();
		let yAxisShelfData = Shelf.yAxis.getCapsuleData();

		let isXAxisShelfNumberOfRecords = !isXAxisShelfEmpty && xAxisShelfData.attributeName == 'Number of Records' && xAxisShelfData.isAutoGenerated;
		let isYAxisShelfNumberOfRecords = !isYAxisShelfEmpty && yAxisShelfData.attributeName == 'Number of Records' && yAxisShelfData.isAutoGenerated;
		let isXAxisShelfQuantitative = !isXAxisShelfEmpty && xAxisShelfData.type == 'quantitative' && xAxisShelfData.aggregate == 'none';
		let isYAxisShelfQuantitative = !isYAxisShelfEmpty && yAxisShelfData.type == 'quantitative' && yAxisShelfData.aggregate == 'none';
		let isXAxisShelfTemporal = !isXAxisShelfEmpty && xAxisShelfData.type == 'temporal';
		let isYAxisShelfTemporal = !isYAxisShelfEmpty && yAxisShelfData.type == 'temporal';

		return (isXAxisShelfTemporal || (isXAxisShelfQuantitative && !isXAxisShelfNumberOfRecords)) && 
	   		   (isYAxisShelfTemporal || (isYAxisShelfQuantitative && !isYAxisShelfNumberOfRecords));
	},

	// trend line loose matching

	areChosenAttrSatifyTrendLineReq: function() {
		const self = this;
		let allSelectedAttributes = DimensionMeasurePaneCapsules.getSelectedCapsuleData();
		let allAttributesOnShelves = Shelves.getOccupiedShelfCapsuleData();
		let allChosenAttributes = allSelectedAttributes.concat(allAttributesOnShelves);
		let attributesByType = self.getAttributeByType(allChosenAttributes);

		let chosenAttrHasTwoQuantOrTemp = (attributesByType.quantitative.length == 2 && attributesByType.temporal.length == 0 && attributesByType.nominal.length == 0 && attributesByType.ordinal.length == 0 && attributesByType.otherNotAllowed.length == 0)
									   || (attributesByType.quantitative.length == 0 && attributesByType.temporal.length == 2 && attributesByType.nominal.length == 0 && attributesByType.ordinal.length == 0 && attributesByType.otherNotAllowed.length == 0)
									   || (attributesByType.quantitative.length == 1 && attributesByType.temporal.length == 1 && attributesByType.nominal.length == 0 && attributesByType.ordinal.length == 0 && attributesByType.otherNotAllowed.length == 0);
		let chosenAttrHasTwoQuantOrTempAndOneNominal = (attributesByType.quantitative.length == 2 && attributesByType.temporal.length == 0 && attributesByType.nominal.length == 1 && attributesByType.ordinal.length == 0 && attributesByType.otherNotAllowed.length == 0)
									   				|| (attributesByType.quantitative.length == 0 && attributesByType.temporal.length == 2 && attributesByType.nominal.length == 1 && attributesByType.ordinal.length == 0 && attributesByType.otherNotAllowed.length == 0)
									  			    || (attributesByType.quantitative.length == 1 && attributesByType.temporal.length == 1 && attributesByType.nominal.length == 1 && attributesByType.ordinal.length == 0 && attributesByType.otherNotAllowed.length == 0);

		return (chosenAttrHasTwoQuantOrTemp || chosenAttrHasTwoQuantOrTempAndOneNominal);
	},

	// trend line adjust specification

	adjustSpecForTrendLines: function() {
		const self = this;
		let allSelectedAttributes = DimensionMeasurePaneCapsules.getSelectedCapsuleData();
		let allAttributesOnShelves = Shelves.getOccupiedShelfCapsuleData();
		let allChosenAttributes = allSelectedAttributes.concat(allAttributesOnShelves);
		let attributesByType = self.getAttributeByType(allChosenAttributes);

		let chosenAttrHasTwoQuantOrTemp = (attributesByType.quantitative.length == 2 && attributesByType.temporal.length == 0 && attributesByType.nominal.length == 0 && attributesByType.ordinal.length == 0 && attributesByType.otherNotAllowed.length == 0)
									   || (attributesByType.quantitative.length == 0 && attributesByType.temporal.length == 2 && attributesByType.nominal.length == 0 && attributesByType.ordinal.length == 0 && attributesByType.otherNotAllowed.length == 0)
									   || (attributesByType.quantitative.length == 1 && attributesByType.temporal.length == 1 && attributesByType.nominal.length == 0 && attributesByType.ordinal.length == 0 && attributesByType.otherNotAllowed.length == 0);
		let chosenAttrHasTwoQuantOrTempAndOneNominal = (attributesByType.quantitative.length == 2 && attributesByType.temporal.length == 0 && attributesByType.nominal.length == 1 && attributesByType.ordinal.length == 0 && attributesByType.otherNotAllowed.length == 0)
									   				|| (attributesByType.quantitative.length == 0 && attributesByType.temporal.length == 2 && attributesByType.nominal.length == 1 && attributesByType.ordinal.length == 0 && attributesByType.otherNotAllowed.length == 0)
									  			    || (attributesByType.quantitative.length == 1 && attributesByType.temporal.length == 1 && attributesByType.nominal.length == 1 && attributesByType.ordinal.length == 0 && attributesByType.otherNotAllowed.length == 0);

		if (chosenAttrHasTwoQuantOrTemp) {
			[ xAttribute, yAttribute ] = self.getAxisAttributes(attributesByType);
			Shelves.emptyAll();
			DimensionMeasurePaneCapsules.clearAllSelection();
			self.addToShelf(xAttribute, 'xAxis');
			self.addToShelf(yAttribute, 'yAxis');
		}

		if (chosenAttrHasTwoQuantOrTempAndOneNominal) {
			let colourAttribute = attributesByType.nominal[0];
			[ xAttribute, yAttribute ] = self.getAxisAttributes(attributesByType);
			Shelves.emptyAll();
			DimensionMeasurePaneCapsules.clearAllSelection();
			self.addToShelf(xAttribute, 'xAxis');
			self.addToShelf(yAttribute, 'yAxis');
			self.addToShelf(colourAttribute, 'colour');
		}
	},
	getAxisAttributes: function(attributesByType) {
		let isXAxisOccupied = !Shelf.xAxis.isEmpty();
		let isYAxisOccupied = !Shelf.yAxis.isEmpty();
		let firstQuantOrTempAttr = null;
		let secondQuantOrTempAttr = null;
		let hasTemporalAttributes = (attributesByType.temporal.length != 0);
		let xAttribute = null;
		let yAttribute = null;

		// get the temporal or quantitative attributes
		if (attributesByType.quantitative.length == 0) {
			firstQuantOrTempAttr = attributesByType.temporal[0];
			secondQuantOrTempAttr = attributesByType.temporal[1];
		}
		if (attributesByType.quantitative.length == 1) {
			firstQuantOrTempAttr = attributesByType.temporal[0];
			secondQuantOrTempAttr = attributesByType.quantitative[0];
		}
		if (attributesByType.quantitative.length == 2) {
			firstQuantOrTempAttr = attributesByType.quantitative[0];
			secondQuantOrTempAttr = attributesByType.quantitative[1];
		}

		// handle one attribute on shelf (two matches default template)
		if (isXAxisOccupied) {
			let xAxisCapsuleData = Shelf.xAxis.getCapsuleData();
			let xAxisAttributeName = xAxisCapsuleData.attributeName;
			xAttribute = (xAxisAttributeName == firstQuantOrTempAttr.attributeName) ? firstQuantOrTempAttr : secondQuantOrTempAttr;
			yAttribute = (xAxisAttributeName == firstQuantOrTempAttr.attributeName) ? secondQuantOrTempAttr : firstQuantOrTempAttr;
		}
		else if (isYAxisOccupied) {
			let yAxisCapsuleData = Shelf.yAxis.getCapsuleData();
			let yAxisAttributeName = yAxisCapsuleData.attributeName;
			xAttribute = (yAxisAttributeName == firstQuantOrTempAttr.attributeName) ? secondQuantOrTempAttr : firstQuantOrTempAttr;
			yAttribute = (yAxisAttributeName == firstQuantOrTempAttr.attributeName) ? firstQuantOrTempAttr : secondQuantOrTempAttr;			
		}

		// handle no attribute on shelf
		else if (!isXAxisOccupied && !isYAxisOccupied && hasTemporalAttributes) {
			xAttribute = (firstQuantOrTempAttr.type == 'temporal') ? firstQuantOrTempAttr : secondQuantOrTempAttr;
			yAttribute = (firstQuantOrTempAttr.type == 'temporal') ? secondQuantOrTempAttr : firstQuantOrTempAttr;
		}
		else if (!isXAxisOccupied && !isYAxisOccupied && !hasTemporalAttributes) {
			xAttribute = firstQuantOrTempAttr;
			yAttribute = secondQuantOrTempAttr;
		}

		return [ xAttribute, yAttribute ];
	},

	// helpers

	addToShelf: function(capsuleData, shelfName) {
		let copiedCapsuleData = $.extend(true, {}, capsuleData);
		let attributeName = capsuleData.attributeName;
		let attributeType = capsuleData.type;
		let attributeAggregateOrTimeUnit = '';
		let needParenthesis = (attributeAggregateOrTimeUnit === '') ? false : true;
		let isAttrAutoGenerated = capsuleData.isAutoGenerated;
		let isAttrOriginallyNominal = (Database.attributeMetadata[attributeName].type == 'nominal');

		// visually add capsule to shelf
		Shelf[shelfName].createCapsule(isAttrAutoGenerated, isAttrOriginallyNominal);
		Shelf[shelfName].installCapsuleTooltip();
		Shelf[shelfName].installRemoveButtonBehaviour();
		Shelf[shelfName].installDragCapsuleBehaviour(); // setting button handled in Listener class
		Shelf[shelfName].changeCapsuleAttributeType(attributeType);
		Shelf[shelfName].changeCapsuleAttributeName(attributeName, needParenthesis);
		Shelf[shelfName].changeAggregateOrTimeUnit(attributeAggregateOrTimeUnit);
		Shelf[shelfName].adjustAttributeNameWidth();

		// store data
		copiedCapsuleData.aggregate = 'none';
		copiedCapsuleData.timeUnit = 'none';
		copiedCapsuleData.attributeName = attributeName;
		copiedCapsuleData.isAddedByUser = false;
		copiedCapsuleData.capsuleLocation = 'shelf';
		Shelf[shelfName].storeCapsuleData(copiedCapsuleData);
	},
	getAttributeByType: function(attributeList) {
		let quantitativeAttributeList = [];
		let nominalAttributeList = [];
		let temporalAttributeList = [];
		let ordinalAttributeList = [];
		let otherAllowedAttributeList = [];
		let otherNotAllowedAttributeList = [];

		for (let i = 0; i < attributeList.length; i++) {
			let currentAttribute = attributeList[i];
			let currentAttributeName = currentAttribute.attributeName;
			let numberOfUniqueValues = (currentAttributeName in Database.uniqueValuesForEachAttribute)
									 ? Database.uniqueValuesForEachAttribute[currentAttributeName].length : 0;
			let isTooManyCategories = (numberOfUniqueValues > 51);

			let isCurrentAttrQuantitative = (currentAttribute.type == 'quantitative');
			let isCurrentAttrNominal = (currentAttribute.type == 'nominal');
			let isCurrentAttrTemporal = (currentAttribute.type == 'temporal');
			let isCurrentAttrOrdinal = (currentAttribute.type == 'ordinal');
			let isCurrentAttrAutoGenerated = (currentAttribute.attributeName == 'Number of Records' && currentAttribute.isAutoGenerated);
			
			if (isCurrentAttrQuantitative && !isCurrentAttrAutoGenerated)
				quantitativeAttributeList.push(currentAttribute);
			if (isCurrentAttrNominal && !isTooManyCategories)
				nominalAttributeList.push(currentAttribute);
			if (isCurrentAttrTemporal)
				temporalAttributeList.push(currentAttribute);
			if (isCurrentAttrOrdinal)
				ordinalAttributeList.push(currentAttribute)
			if (isCurrentAttrNominal && isTooManyCategories)
				otherNotAllowedAttributeList.push(currentAttribute);
			if (isCurrentAttrAutoGenerated)
				otherAllowedAttributeList.push(currentAttribute);
		}

		return {
			quantitative: quantitativeAttributeList,
			nominal: nominalAttributeList,
			temporal: temporalAttributeList,
			ordinal: ordinalAttributeList,
			otherAllowed: otherAllowedAttributeList,
			otherNotAllowed: otherNotAllowedAttributeList
		}
	}
}