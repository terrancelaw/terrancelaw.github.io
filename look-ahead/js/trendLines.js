const TrendLines = {
	xAxisAttribute: null, // { name, min, max, isTemporal, timeUnit }
	yAxisAttribute: null, // { name, min, max, isTemporal, timeUnit }
	splittingAttributes: null, // { encodingName: { encodingName, name, numberOfBins, isQuantitativeBin, isTemporal, timeUnit, min, max, binSize, allGroups } }
	nonSplittingAttributes: null, // { encodingName: { encodingName, name } }

	dataAfterFiltering: null,
	allGroups: null, // [ { splittingAttributes: { encodingName: { name, value } ... }, objects, regressionParam, pointsOnTrendLine }]
	categoryToColourDict: {},
	stopGeneratingSpec: null,

	applyConstraints: function() {
		const self = this;

		self.applyNumberOfRecordsConstraints([ 'row', 'column', 'shape' ]);
		self.applyBinConstraints([ 'row', 'column', 'shape' ]);
		self.applyYearConstraints([ 'xAxis', 'yAxis', 'row', 'column', 'size', 'colour', 'shape', 'tooltip' ]);
	},
	applyNumberOfRecordsConstraints: function(shelfNames) {
		const self = this;
		let stopGeneratingSpec = false;

		for (let i = 0; i < shelfNames.length; i++) {
			let currentShelfName = shelfNames[i];
			let currentShelfData = Shelf[currentShelfName].getCapsuleData();
			let isCurrentShelfEmpty = Shelf[currentShelfName].isEmpty();

			if (!isCurrentShelfEmpty) {
				let isCurrentShelfNumberOfRecords = 
					currentShelfData.type == 'quantitative' && 
					currentShelfData.attributeName == 'Number of Records' && 
					currentShelfData.isAutoGenerated;

				if (isCurrentShelfNumberOfRecords) {
					Shelves.restoreState();
					Shelf[currentShelfName].blink();
					VisualizationPane.stopUpdating();
					stopGeneratingSpec = true;
					break;
				}
			}
		}

		self.stopGeneratingSpec = stopGeneratingSpec;
	},
	applyBinConstraints: function(shelfNames) {
		const self = this;

		if (self.stopGeneratingSpec)
			return;

		for (let i = 0; i < shelfNames.length; i++) {
			let currentShelfName = shelfNames[i];
			let currentShelfData = Shelf[currentShelfName].getCapsuleData();
			let isCurrentShelfEmpty = Shelf[currentShelfName].isEmpty();

			if (!isCurrentShelfEmpty) {
				let isCurrentShelfQuantitative = currentShelfData.type == 'quantitative';
				let isCurrentShelfNumberOfRecords = 
					currentShelfData.type == 'quantitative' && 
					currentShelfData.attributeName == 'Number of Records' && 
					currentShelfData.isAutoGenerated;

				if (isCurrentShelfQuantitative && !isCurrentShelfNumberOfRecords) {
					currentShelfData.aggregate = 'bin';
					Shelves.refreshCapsules();
				}
			}
		}
	},
	applyYearConstraints: function(shelfNames) {
		const self = this;

		if (self.stopGeneratingSpec)
			return;

		for (let i = 0; i < shelfNames.length; i++) {
			let currentShelfName = shelfNames[i];
			let currentShelfData = Shelf[currentShelfName].getCapsuleData();
			let isCurrentShelfEmpty = Shelf[currentShelfName].isEmpty();

			if (!isCurrentShelfEmpty) {
				let isCurrentShelfTemporal = currentShelfData.type == 'temporal';
				let isCurrentShelfTimeUnitUnset = currentShelfData.timeUnit == 'none';

				if (isCurrentShelfTemporal && isCurrentShelfTimeUnitUnset) {
					currentShelfData.timeUnit = 'year';
					Shelves.refreshCapsules();
				}
			}
		}
	},
	init: function() {
		const self = this;
		let xAxisShelfData = Shelf.xAxis.getCapsuleData();
		let yAxisShelfData = Shelf.yAxis.getCapsuleData();
		let colourShelfData = Shelf.colour.getCapsuleData();
		let rowShelfData = Shelf.row.getCapsuleData();
		let columnShelfData = Shelf.column.getCapsuleData();
		let sizeShelfData = Shelf.size.getCapsuleData();
		let shapeShelfData = Shelf.shape.getCapsuleData();

		let isColourShelfEmpty = Shelf.colour.isEmpty()
		let isRowShelfEmpty = Shelf.row.isEmpty();
		let isColumnShelfEmpty = Shelf.column.isEmpty();
		let isSizeShelfEmpty = Shelf.size.isEmpty();
		let isShapeShelfEmpty = Shelf.shape.isEmpty();

		let splitAttrOnColorShelf = isColourShelfEmpty ? false : self.isSplittingAttribute(colourShelfData);
		let splitAttrOnRowShelf = isRowShelfEmpty ? false : self.isSplittingAttribute(rowShelfData);
		let splitAttrOnColumnShelf = isColumnShelfEmpty ? false : self.isSplittingAttribute(columnShelfData);
		let splitAttrOnSizeShelf = isSizeShelfEmpty ? false : self.isSplittingAttribute(sizeShelfData);
		let splitAttrOnShapeShelf = isShapeShelfEmpty ? false : self.isSplittingAttribute(shapeShelfData);

		let xAxisAttribute = self.createAxisAttribute(xAxisShelfData);
		let yAxisAttribute = self.createAxisAttribute(yAxisShelfData);
		let splittingAttributes = null;
		let nonSplittingAttributes = null;

		if ((!isColourShelfEmpty && splitAttrOnColorShelf) ||
			(!isRowShelfEmpty && splitAttrOnRowShelf) ||
			(!isColumnShelfEmpty && splitAttrOnColumnShelf) ||
			(!isSizeShelfEmpty && splitAttrOnSizeShelf) ||
			(!isShapeShelfEmpty && splitAttrOnShapeShelf)) splittingAttributes = {};
		if ((!isColourShelfEmpty && !splitAttrOnColorShelf) ||
			(!isRowShelfEmpty && !splitAttrOnRowShelf) ||
			(!isColumnShelfEmpty && !splitAttrOnColumnShelf) ||
			(!isSizeShelfEmpty && !splitAttrOnSizeShelf) ||
			(!isShapeShelfEmpty && !splitAttrOnShapeShelf)) nonSplittingAttributes = {};

		if (!isColourShelfEmpty && splitAttrOnColorShelf) splittingAttributes.color = self.createSplittingAttribute(colourShelfData, 'color');
		if (!isRowShelfEmpty && splitAttrOnRowShelf) splittingAttributes.row = self.createSplittingAttribute(rowShelfData, 'row');
		if (!isColumnShelfEmpty && splitAttrOnColumnShelf) splittingAttributes.column = self.createSplittingAttribute(columnShelfData, 'column');
		if (!isSizeShelfEmpty && splitAttrOnSizeShelf) splittingAttributes.size = self.createSplittingAttribute(sizeShelfData, 'size');
		if (!isShapeShelfEmpty && splitAttrOnShapeShelf) splittingAttributes.shape = self.createSplittingAttribute(shapeShelfData, 'shape');

		if (!isColourShelfEmpty && !splitAttrOnColorShelf) nonSplittingAttributes.color = self.createNonSplittingAttribute(colourShelfData, 'color');
		if (!isRowShelfEmpty && !splitAttrOnRowShelf) nonSplittingAttributes.row = self.createNonSplittingAttribute(rowShelfData, 'row');
		if (!isColumnShelfEmpty && !splitAttrOnColumnShelf) nonSplittingAttributes.column = self.createNonSplittingAttribute(columnShelfData, 'column');
		if (!isSizeShelfEmpty && !splitAttrOnSizeShelf) nonSplittingAttributes.size = self.createNonSplittingAttribute(sizeShelfData, 'size');
		if (!isShapeShelfEmpty && !splitAttrOnShapeShelf) nonSplittingAttributes.shape = self.createNonSplittingAttribute(shapeShelfData, 'shape');

		self.xAxisAttribute = xAxisAttribute;
		self.yAxisAttribute = yAxisAttribute;
		self.splittingAttributes = splittingAttributes;
		self.nonSplittingAttributes = nonSplittingAttributes;
	},
	isSplittingAttribute: function(shelfData) {
		return (shelfData.type == 'ordinal' || shelfData.type == 'nominal') || 
			   (shelfData.type == 'quantitative' && shelfData.aggregate == 'bin') ||
			   (shelfData.type == 'temporal' && shelfData.timeUnit == 'year') ||
			   (shelfData.type == 'temporal' && shelfData.timeUnit == 'month') || 
			   (shelfData.type == 'temporal' && shelfData.timeUnit == 'day');
	},
	createAxisAttribute: function(shelfData) {
		let axisAttribute = {};

		axisAttribute.name = null;
		axisAttribute.min = null;
		axisAttribute.max = null;
		axisAttribute.isTemporal = null;
		axisAttribute.timeUnit = null;

		if (shelfData.type == 'temporal') {
			axisAttribute.isTemporal = true;
			axisAttribute.timeUnit = (shelfData.timeUnit == 'none') ? 'year' : shelfData.timeUnit;
			axisAttribute.name = shelfData.attributeName + ' (' + axisAttribute.timeUnit + ')';
		}

		if (shelfData.type != 'temporal') {
			axisAttribute.isTemporal = false;
			axisAttribute.timeUnit = null;
			axisAttribute.name = shelfData.attributeName;
		}

		return axisAttribute;
	},
	createSplittingAttribute: function(shelfData, encodingName) {
		let splittingAttribute = {};

		splittingAttribute.name = null;
		splittingAttribute.encodingName = encodingName;
		splittingAttribute.isQuantitativeBin = (shelfData.type == 'quantitative' && shelfData.aggregate == 'bin');
		splittingAttribute.numberOfBins = null;
		splittingAttribute.min = null;
		splittingAttribute.max = null;
		splittingAttribute.binSize = null;
		splittingAttribute.isTemporal = shelfData.type == 'temporal';
		splittingAttribute.timeUnit = (shelfData.type == 'temporal') ? shelfData.timeUnit : null;
		splittingAttribute.allGroups = null;

		// name
		if (splittingAttribute.isTemporal)
			splittingAttribute.name = shelfData.attributeName + ' (' + splittingAttribute.timeUnit + ')';
		if (!splittingAttribute.isTemporal)
			splittingAttribute.name = shelfData.attributeName;

		// number of bins
		if (splittingAttribute.isQuantitativeBin && shelfData.maxbins == 'none')
			splittingAttribute.numberOfBins = 5; // default
		if (splittingAttribute.isQuantitativeBin && shelfData.maxbins != 'none') 
			splittingAttribute.numberOfBins = shelfData.maxbins;

		return splittingAttribute;
	},
	createNonSplittingAttribute: function(shelfData, encodingName) {
		let nonSplittingAttribute = {};

		nonSplittingAttribute.name = shelfData.attributeName;
		nonSplittingAttribute.encodingName = encodingName;

		return nonSplittingAttribute;
	},

	// get data

	filterData: function() {
		const self = this;
		let xAxisAttribute = self.xAxisAttribute;
		let yAxisAttribute = self.yAxisAttribute;
		let splittingAttributes = self.splittingAttributes;
		let dataAfterApplyingFilters = Filters.getFilteredData();
		let dataAfterRemovingMissingValues = [];

		for (let i = 0; i < dataAfterApplyingFilters.length; i++) {
			let currentRow = dataAfterApplyingFilters[i];
			let currentxAxisAttrValue = currentRow[xAxisAttribute.name];
			let currentyAxisAttrValue = currentRow[yAxisAttribute.name];
			let isAtLeastOneAxisValueMissing = (currentxAxisAttrValue === null || currentyAxisAttrValue === null);
			let isAtLeastOneSplittingAttrValueMissing = false;

			// find isAtLeastOneSplittingAttrValueMissing
			for (let encodingName in splittingAttributes) {
				let currentSplittingAttribute = splittingAttributes[encodingName];
				let currentSplittingAttrValue = currentRow[currentSplittingAttribute.name];

				if (currentSplittingAttrValue === null) {
					isAtLeastOneSplittingAttrValueMissing = true;
					break;
				}
			}

			// save if none is missing
			if (!(isAtLeastOneAxisValueMissing || isAtLeastOneSplittingAttrValueMissing))
				dataAfterRemovingMissingValues.push(currentRow);
		}

		self.dataAfterFiltering = dataAfterRemovingMissingValues;
	},
	findMinMax: function() {
		const self = this;
		let xAxisAttribute = self.xAxisAttribute;
		let yAxisAttribute = self.yAxisAttribute;
		let splittingAttributes = self.splittingAttributes;
		let quantBinSplittingAttributes = [];

		// init
		xAxisAttribute.min = Infinity;
		xAxisAttribute.max = -Infinity;
		yAxisAttribute.min = Infinity;
		yAxisAttribute.max = -Infinity;

		for (let encodingName in splittingAttributes) {
			let currentSplittingAttribute = splittingAttributes[encodingName];

			if (currentSplittingAttribute.isQuantitativeBin) {
				currentSplittingAttribute.min = Infinity;
				currentSplittingAttribute.max = -Infinity;
				quantBinSplittingAttributes.push(currentSplittingAttribute);
			}
		}

		// find min max
		for (let i = 0; i < self.dataAfterFiltering.length; i++) {
			let currentRow = self.dataAfterFiltering[i];
			let currentXAxisValue = +currentRow[xAxisAttribute.name];
			let currentYAxisValue = +currentRow[yAxisAttribute.name];

			// find for x axis attribute
			if (currentXAxisValue < xAxisAttribute.min) xAxisAttribute.min = currentXAxisValue;
			if (currentXAxisValue > xAxisAttribute.max) xAxisAttribute.max = currentXAxisValue;

			// find for y axis attribute
			if (currentYAxisValue < yAxisAttribute.min) yAxisAttribute.min = currentYAxisValue;
			if (currentYAxisValue > yAxisAttribute.max) yAxisAttribute.max = currentYAxisValue;

			// find for splitting attributes
			for (let j = 0; j < quantBinSplittingAttributes.length; j++) {
				let currentSplittingAttribute = quantBinSplittingAttributes[j];
				let currentSplittingAttrValue = +currentRow[currentSplittingAttribute.name];

				if (currentSplittingAttrValue < currentSplittingAttribute.min) currentSplittingAttribute.min = currentSplittingAttrValue;
				if (currentSplittingAttrValue > currentSplittingAttribute.max) currentSplittingAttribute.max = currentSplittingAttrValue;
			}
		}

		// find bin size for quantitative bin splitting attributes
		for (let i = 0; i < quantBinSplittingAttributes.length; i++) {
			let currentSplittingAttribute = quantBinSplittingAttributes[i];
			currentSplittingAttribute.binSize = (currentSplittingAttribute.max - currentSplittingAttribute.min) / currentSplittingAttribute.numberOfBins;
		}
	},
	
	// group combinations

	generateAllGroupCombinations: function() {
		const self = this;
		let splittingAttributes = self.splittingAttributes;

		if (splittingAttributes !== null) {
			self.findAllGroupsForEachSplittingAttribute();
			self.findAllGroupCombinations();
			self.createCategoryToColourDict();
			self.retrieveObjectsForEachGroup();
		}

		if (splittingAttributes === null)
			self.allGroups = [{
				splittingAttributes: null,
				objects: self.dataAfterFiltering,
				regressionParam: {},
				pointsOnTrendLine: []
			}];
	},
	findAllGroupsForEachSplittingAttribute: function() {
		const self = this;
		let splittingAttributes = self.splittingAttributes;

		for (let encodingName in splittingAttributes) {
			let currentSplittingAttribute = splittingAttributes[encodingName];

			if (currentSplittingAttribute.isQuantitativeBin) {
				currentSplittingAttribute.allGroups = [];

				for (let i = 0; i < currentSplittingAttribute.numberOfBins; i++)
					currentSplittingAttribute.allGroups.push(i);
			}

			if (currentSplittingAttribute.isTemporal) {
				let getYear = currentSplittingAttribute.timeUnit == "year";
				let getMonth = currentSplittingAttribute.timeUnit == "month";
				let getWeek = currentSplittingAttribute.timeUnit == "day";
				let timeNameArray = [];
				let timeObject = {};

				for (let i = 0; i < self.dataAfterFiltering.length; i++) {
					let currentRow = self.dataAfterFiltering[i];
					let currentTime = currentRow[currentSplittingAttribute.name];
					let currentTimeString = null;

					if (getYear) currentTimeString = currentTime.toString();
					if (getMonth) currentTimeString = Helpers.getMonthName(currentTime);
					if (getWeek) currentTimeString = Helpers.getWeekdayName(currentTime);
					timeObject[currentTimeString] = null;
				}

				timeNameArray = Object.keys(timeObject);
				if (getYear) timeNameArray.sort();
				if (getMonth) timeNameArray = Helpers.sortMonthNames(timeNameArray);
				if (getWeek) timeNameArray = Helpers.sortWeekdayNames(timeNameArray);
				currentSplittingAttribute.allGroups = timeNameArray;
			}

			if (!currentSplittingAttribute.isQuantitativeBin && !currentSplittingAttribute.isTemporal) {
				let categoryObject = {};

				for (let i = 0; i < self.dataAfterFiltering.length; i++) {
					let currentRow = self.dataAfterFiltering[i];
					let currentCategory = currentRow[currentSplittingAttribute.name];

					categoryObject[currentCategory] = null;
				}

				currentSplittingAttribute.allGroups = Object.keys(categoryObject);
				currentSplittingAttribute.allGroups.sort();
			}
		}
	},
	findAllGroupCombinations: function() {
		const self = this;
		let splittingAttributes = self.splittingAttributes;
		let splittingAttributeArray = [];
		let numberOfGroupCombinations = 1;
		let allGroupCombinations = [];

		// initialization
		for (let encodingName in splittingAttributes)
			splittingAttributeArray.push(splittingAttributes[encodingName]);

		for (let i = 0; i < splittingAttributeArray.length; i++) {
			let currentSplittingAttribute = splittingAttributeArray[i];
			let currentMagicNumber = 1;

			if (i > 0) 
				for (let j = 0; j < i; j++) 
					currentMagicNumber *= splittingAttributeArray[j].allGroups.length;

			currentSplittingAttribute.magicNumber = currentMagicNumber
			numberOfGroupCombinations *= currentSplittingAttribute.allGroups.length;
		}

		for (let i = 0; i < numberOfGroupCombinations; i++)
			allGroupCombinations.push({
				splittingAttributes: {},
				objects: [],
				regressionParam: {},
				pointsOnTrendLine: []
			});

		// create allGroupCombinations
		for (let i = 0; i < splittingAttributeArray.length; i++) {
			let currentSplittingAttribute = splittingAttributeArray[i];
			let currentSplittingAttrGroupIndex = -1;
			let currentSplittingAttrGroup = null;
			let currentMagicNumber = currentSplittingAttribute.magicNumber;

			for (let j = 0; j < numberOfGroupCombinations; j++) {
				let attributeObject = {};

				if (j % currentMagicNumber == 0) { // get currentSplittingAttrGroup
					currentSplittingAttrGroupIndex++;
					currentSplittingAttrGroupIndex = currentSplittingAttrGroupIndex % currentSplittingAttribute.allGroups.length;
					currentSplittingAttrGroup = currentSplittingAttribute.allGroups[currentSplittingAttrGroupIndex];
				}

				attributeObject.name = currentSplittingAttribute.name;
				attributeObject.value = currentSplittingAttrGroup;
				allGroupCombinations[j].splittingAttributes[currentSplittingAttribute.encodingName] = attributeObject;			
			}
		}

		self.allGroups = allGroupCombinations;
	},
	createCategoryToColourDict: function() {
		const self = this;
		let splittingAttributes = self.splittingAttributes;
		let colourShelfHasSplitAttr = splittingAttributes !== null && 'color' in splittingAttributes;
		let categoryToColourDict = {};

		if (colourShelfHasSplitAttr)
			for (let i = 0; i < splittingAttributes.color.allGroups.length; i++) {
				let currentColourIndex = i;
				let currentColourCode = Helpers.getTableau10Colour(currentColourIndex);
				let currentGroup = splittingAttributes.color.allGroups[i];

				categoryToColourDict[currentGroup] = currentColourCode;
			}

		self.categoryToColourDict = categoryToColourDict;
	},
	retrieveObjectsForEachGroup: function() {
		const self = this;
		let splittingAttributes = self.splittingAttributes;

		for (let i = 0; i < self.dataAfterFiltering.length; i++) {
			let currentRow = self.dataAfterFiltering[i];

			for (let j = 0; j < self.allGroups.length; j++) {
				let currentGroup = self.allGroups[j];
				let satisfyGroupDefinition = true;

				for (let encodingName in currentGroup.splittingAttributes) {
					let currentSplittingAttribute = splittingAttributes[encodingName];
					let currentGroupValue = currentGroup.splittingAttributes[encodingName].value;
					let currentRowValue = currentRow[currentSplittingAttribute.name];
					let currentRowCategory = null;

					if (currentSplittingAttribute.isQuantitativeBin) {
						currentRowValue = +currentRowValue;
						currentRowCategory = Math.floor((currentRowValue - currentSplittingAttribute.min) / currentSplittingAttribute.binSize);

						if (currentRowCategory >= currentSplittingAttribute.numberOfBins)
							currentRowCategory = currentSplittingAttribute.numberOfBins - 1;
					}

					if (currentSplittingAttribute.isTemporal) {
						let getYear = currentSplittingAttribute.timeUnit == "year";
						let getMonth = currentSplittingAttribute.timeUnit == "month";
						let getWeek = currentSplittingAttribute.timeUnit == "day";

						if (getYear) currentRowCategory = currentRowValue.toString();
						if (getMonth) currentRowCategory = Helpers.getMonthName(currentRowValue);
						if (getWeek) currentRowCategory = Helpers.getWeekdayName(currentRowValue);
					}

					if (!currentSplittingAttribute.isQuantitativeBin && 
						!currentSplittingAttribute.isTemporal)
						currentRowCategory = currentRowValue;

					if (currentRowCategory !== currentGroupValue) {
						satisfyGroupDefinition = false;
						break;
					}
				}

				if (satisfyGroupDefinition) {
					currentGroup.objects.push(currentRow);
					break;
				}
			}
		}
	},

	// trend lines

	computeRegressionParamForEachGroup: function() {
		const self = this;
		let xAxisAttribute = self.xAxisAttribute;
		let yAxisAttribute = self.yAxisAttribute;

		for (let i = 0; i < self.allGroups.length; i++) {
			let currentGroup = self.allGroups[i];
			let pointsForCurrentGroup = [];

			// create data point array
			for (let j = 0; j < currentGroup.objects.length; j++) {
				let currentRow = currentGroup.objects[j];
				let currentXValue = +currentRow[xAxisAttribute.name];
				let currentYValue = +currentRow[yAxisAttribute.name];

				pointsForCurrentGroup.push([ currentXValue, currentYValue ]);
			}

			// return parameters
			if (pointsForCurrentGroup.length < 2)
				currentGroup.regressionParam = null;

			if (pointsForCurrentGroup.length >= 2) {
				let parameters = Regression.linear(pointsForCurrentGroup);

				currentGroup.regressionParam = { 
					slope: parameters.equation[0], 
					yIntercept: parameters.equation[1] 
				};
			}
		}
	},
	generatePointsOnTrendLineForEachGroup: function() {
		const self = this;
		let isRowShelfEmpty = Shelf.row.isEmpty();
		let isColumnShelfEmpty = Shelf.column.isEmpty();
		let hasRowOrColumn = !isRowShelfEmpty || !isColumnShelfEmpty;
		let numberOfPointsOnTrendLine = hasRowOrColumn ? 30 : 100;

		let xAxisAttribute = self.xAxisAttribute;
		let yAxisAttribute = self.yAxisAttribute;

		let groupsWithRegressionParam = [];
		let endPointsOnTrendLine = [];
		let shortVectorForEachTrendLine = [];

		// init
		for (let i = 0; i < self.allGroups.length; i++) {
			let currentGroup = self.allGroups[i];

			if (currentGroup.regressionParam !== null)
				groupsWithRegressionParam.push(currentGroup);
		}

		// finding end points
		for (let i = 0; i < groupsWithRegressionParam.length; i++) {
			let currentGroup = groupsWithRegressionParam[i];
			let currentSlope = currentGroup.regressionParam.slope;
			let currentYIntercept = currentGroup.regressionParam.yIntercept;
			let currentEndPoints = [];

			let point1 = { x: xAxisAttribute.min, y: currentSlope * xAxisAttribute.min + currentYIntercept };
			let point2 = { x: xAxisAttribute.max, y: currentSlope * xAxisAttribute.max + currentYIntercept };
			let point3 = { x: (yAxisAttribute.min - currentYIntercept) / currentSlope, y: yAxisAttribute.min };
			let point4 = { x: (yAxisAttribute.max - currentYIntercept) / currentSlope, y: yAxisAttribute.max };
			let possibleEndPoints = [ point1, point2, point3, point4 ];

			for (let j = 0; j < possibleEndPoints.length; j++)
				if (possibleEndPoints[j].x >= xAxisAttribute.min && possibleEndPoints[j].x <= xAxisAttribute.max && 
					possibleEndPoints[j].y >= yAxisAttribute.min && possibleEndPoints[j].y <= yAxisAttribute.max)
					currentEndPoints.push(possibleEndPoints[j]);

			endPointsOnTrendLine.push(currentEndPoints); // should have only two points
		}

		// find short vector
		for (let i = 0; i < groupsWithRegressionParam.length; i++) {
			let currentStartingPoint = endPointsOnTrendLine[i][0];
			let currentEndingPoint = endPointsOnTrendLine[i][1];

			let differentVector = { x: currentEndingPoint.x - currentStartingPoint.x, y: currentEndingPoint.y - currentStartingPoint.y };
			let magitudeOfDiffVector = Math.sqrt(differentVector.x * differentVector.x + differentVector.y * differentVector.y);
			let requiredMagitude = magitudeOfDiffVector / numberOfPointsOnTrendLine;
			let unitVector = { x: differentVector.x / magitudeOfDiffVector, y: differentVector.y / magitudeOfDiffVector };
			let shortVector = { x: unitVector.x * requiredMagitude, y: unitVector.y * requiredMagitude };

			shortVectorForEachTrendLine.push(shortVector);
		}

		// generate trend line points
		for (let i = 0; i < groupsWithRegressionParam.length; i++) {
			let currentGroup = groupsWithRegressionParam[i];
			let currentStartingPoint = endPointsOnTrendLine[i][0];
			let currentShortVector = shortVectorForEachTrendLine[i];
			let pointsOnCurrentTrendLine = [];

			for (let j = 0; j < numberOfPointsOnTrendLine; j++)
				pointsOnCurrentTrendLine.push({
					x: currentStartingPoint.x + currentShortVector.x * j,
					y: currentStartingPoint.y + currentShortVector.y * j 
				});

			currentGroup.pointsOnTrendLine = pointsOnCurrentTrendLine;
		}
	},

	// specification

	modifyVegaLiteSpecification: function() {
		const self = this;
		let isRowShelfEmpty = Shelf.row.isEmpty();
		let isColumnShelfEmpty = Shelf.column.isEmpty();
		let hasRowOrColumn = !isRowShelfEmpty || !isColumnShelfEmpty;

		if (!hasRowOrColumn) {
			TrendLinesForUnfacetedCharts.initSpecification();
			TrendLinesForUnfacetedCharts.initScatterplotSpecification();
			TrendLinesForUnfacetedCharts.addScatterplotData();
			TrendLinesForUnfacetedCharts.addScatterplotSpecification();
			TrendLinesForUnfacetedCharts.initTrendLineSpecifications();
			TrendLinesForUnfacetedCharts.addTrendLineData();
			TrendLinesForUnfacetedCharts.addTrendLineSpecifications();
			TrendLinesForUnfacetedCharts.modifySpecificationWidthAndHeight();
			VegaliteGenerator.specification = TrendLinesForUnfacetedCharts.newSpecification;
		}

		if (hasRowOrColumn) {
			TrendLinesForFacetedCharts.initSpecification();
			TrendLinesForFacetedCharts.addData();
			TrendLinesForFacetedCharts.findAllLayers();
			TrendLinesForFacetedCharts.initScatterplotSpecification();
			TrendLinesForFacetedCharts.initTrendLineSpecifications();
			TrendLinesForFacetedCharts.modifySpecificationWidthAndHeight();
			VegaliteGenerator.specification = TrendLinesForFacetedCharts.newSpecification;
		}
	},
	getSortedRanges: function(splittingAttribute) {
		let sortedRanges = [];

		for (let i = 0; i < splittingAttribute.allGroups.length; i++) {
			let currentBinIndex = i;
			let currentLowerBound = splittingAttribute.min + currentBinIndex * splittingAttribute.binSize;
			let currentUpperBound = currentLowerBound + splittingAttribute.binSize;

			if (currentLowerBound.countDecimals() > 2)
				currentLowerBound = currentLowerBound.toFixed(2);
			if (currentUpperBound.countDecimals() > 2)
				currentUpperBound = currentUpperBound.toFixed(2);

			sortedRanges.push(currentLowerBound + ' - ' + currentUpperBound);
		}

		return sortedRanges;
	}
}