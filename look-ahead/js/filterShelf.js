const FilterShelf = {
	position: { left: null, right: null, top: null, bottom: null },
	previousFilters: [],

	createFilter: function(attributeName, attributeType, isAttrAutoGenerated, filterMetadata = null) {
		const self = this;

		let needToSelectMissingValueButton = (filterMetadata !== null && filterMetadata.removeMissing);
		let needToSelectAttributeValues = (filterMetadata !== null && 'attributeValues' in filterMetadata);
		let needToSelectRange = (filterMetadata !== null && 'lowerValue' in filterMetadata);
		let isPreview = (filterMetadata !== null) ? filterMetadata.isPreview : false;
		let needToScroll = (filterMetadata !== null) ? filterMetadata.needToScroll : true;

		let isNumberOfRecords = (attributeName == 'Number of Records' && isAttrAutoGenerated);
		let isRawTemporal = (attributeType == 'temporal' && !isAttrAutoGenerated);
		let updatedAttributeName = isRawTemporal ? (attributeName + ' (year)') : attributeName;
		let newFilter = new FilterTemplate(updatedAttributeName, attributeType);
		let filterAlreadyExists = (newFilter.filterName in Filter);

		// not allow to create if already created
		if (filterAlreadyExists || isNumberOfRecords) {
			self.blink();
			return;
		}
		
		// create capsule
		newFilter.createCapsule(isPreview);
		newFilter.changeAttributeType();
		newFilter.changeAttributeName();
		newFilter.populateCapsuleContent();
		newFilter.installCapsuleBehaviour();

		// handle filterMetadata
		if (needToScroll) {
			ShelfPane.scrollToBottom();
		}
		if (needToSelectMissingValueButton) {
			newFilter.changeMissingValueButton(filterMetadata.removeMissing);
			newFilter.updateSpecificationForMissingValue();
		}
		if (needToSelectAttributeValues) {
			newFilter.checkSelectedItems(filterMetadata.attributeValues);
			newFilter.updateSpecificationForList();
		}
		if (needToSelectRange) {
			newFilter.updateSliderValues([ filterMetadata.lowerValue, filterMetadata.upperValue ]);
			newFilter.updateSliderHandles();
			newFilter.updateSpecificationForSlider();
		}

		// save
		Filter[newFilter.filterName] = newFilter;
	},

	// state

	saveState: function() {
		const self = this;

		// remove previous
		self.previousFilters = [];

		// save based on order
		$('.shelf.filter .capsule').each(function() {
			let filterName = $(this).attr('filter-name');
			let currentFilter = Filter[filterName];
			let currentFilterHasRange = ('range' in currentFilter.filterSpecification);

			let attributeName = currentFilter.attributeName;
			let attributeType = currentFilter.attributeType;
			let filterMetadata = {};

			if (currentFilterHasRange) {
				filterMetadata.removeMissing = currentFilter.removeMissing;
				filterMetadata.lowerValue = Filter[filterName].filterSpecification.range[0];
				filterMetadata.upperValue = Filter[filterName].filterSpecification.range[1];
				filterMetadata.isPreview = false;
			}

			if (!currentFilterHasRange) {
				filterMetadata.removeMissing = currentFilter.removeMissing;
				filterMetadata.attributeValues = currentFilter.filterSpecification.oneOf;
				filterMetadata.isPreview = false;
			}

			self.previousFilters.push({
				attributeName: attributeName,
				type: attributeType,
				filterMetadata: filterMetadata
			});
		});
	},
	restoreState: function() {
		const self = this;

		// remove
		Filters.emptyAll();

		// create
		for (let i = 0; i < self.previousFilters.length; i++) {
			let currentFilter = self.previousFilters[i];
			let attributeName = currentFilter.attributeName;
			let attributeType = currentFilter.type;
			let isAttrAutoGenerated = Database.attributeMetadata[attributeName].isAutoGenerated;
			let filterMetadata = currentFilter.filterMetadata;

			// add capsule
			FilterShelf.createFilter(attributeName, attributeType, isAttrAutoGenerated, filterMetadata);
		}
	},
	clearState: function() {
		const self = this;

		self.previousFilters = [];
	},

	// preview

	preview: function(visSpec) {
		let filterList = visSpec.filter;

		// remove
		Filters.emptyAll();
		if (!('filter' in visSpec)) return;			

		// create
		for (let i = 0; i < filterList.length; i++) {
			let currentFilter = filterList[i];
			let attributeName = currentFilter.attributeName;
			let attributeType = currentFilter.type;
			let isAttrAutoGenerated = Database.attributeMetadata[attributeName].isAutoGenerated;
			let filterMetadata = {
				removeMissing: currentFilter.removeMissing,
				isPreview: currentFilter.added,
				needToScroll: false
			};

			// create metadata
			if ('lowerValue' in currentFilter) filterMetadata.lowerValue = currentFilter.lowerValue;
			if ('upperValue' in currentFilter) filterMetadata.upperValue = currentFilter.upperValue;
			if ('attributeValues' in currentFilter) filterMetadata.attributeValues = currentFilter.attributeValues;

			// add capsule
			FilterShelf.createFilter(attributeName, attributeType, isAttrAutoGenerated, filterMetadata);
		}
	},

	// highlight

	highlight: function() {
		$('#shelf-pane .shelf.filter')
			.addClass('highlight')
			.removeClass('double');
	},
	doubleHighlight: function() {
		$('#shelf-pane .shelf.filter')
			.addClass('highlight')
			.addClass('double');
	},
	removeHighlight: function() {
		$('#shelf-pane .shelf.filter')
			.removeClass('highlight')
			.removeClass('double');
	},
	blink: function() {
		const self = this;

		// add blink class and remove after one sec
		$('#shelf-pane .shelf.filter').addClass('blink');
		setTimeout(function() { $('#shelf-pane .shelf.filter').removeClass('blink'); }, 1000);
	},

	// position

	checkPosition: function() {
		const self = this;
		let shelfPosition = $('#shelf-pane .shelf.filter').offset();
		let shelfWidth = $('#shelf-pane .shelf.filter').width();
		let shelfHeight = $('#shelf-pane .shelf.filter').height();

		self.position.left = shelfPosition.left;
		self.position.right = shelfPosition.left + shelfWidth;
		self.position.top = shelfPosition.top;
		self.position.bottom = shelfPosition.top + shelfHeight;
	},
	isMouseOnTop(mouseX, mouseY) {
		const self = this;

		if (mouseX >= self.position.left && 
			mouseX <= self.position.right &&
			mouseY >= self.position.top &&
			mouseY <= self.position.bottom)
			return true;

		return false;
	}
}