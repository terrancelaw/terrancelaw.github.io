const DensityPlot = {
	distributionAttribute: null, // { name, numberOfBins, min, max, binSize, allGroups }
	splittingAttributes: null, // { encodingName: { encodingName, name, numberOfBins, isQuantitativeBin, isTemporal, timeUnit, min, max, binSize, allGroups } }

	dataAfterFiltering: null,
	allGroups: null, // [ { splittingAttributes: { encodingName: { name, value } ... }, objects, probabilityDistribution }]
	
	stopGeneratingSpec: null,
	newSpecification: null,

	applyConstraints: function() {
		const self = this;

		self.applyNumberOfRecordsConstraints([ 'row', 'column' ]);
		self.applyBinConstraints([ 'row', 'column' ]);
		self.applyYearConstraints([ 'colour', 'row', 'column' ]);
	},
	applyNumberOfRecordsConstraints: function(shelfNames) {
		const self = this;
		let stopGeneratingSpec = false;

		for (let i = 0; i < shelfNames.length; i++) {
			let currentShelfName = shelfNames[i];
			let currentShelfData = Shelf[currentShelfName].getCapsuleData();
			let isCurrentShelfEmpty = Shelf[currentShelfName].isEmpty();

			if (!isCurrentShelfEmpty) {
				let isCurrentShelfNumberOfRecords = 
					currentShelfData.type == 'quantitative' && 
					currentShelfData.attributeName == 'Number of Records' && 
					currentShelfData.isAutoGenerated;

				if (isCurrentShelfNumberOfRecords) {
					Shelves.restoreState();
					Shelf[currentShelfName].blink();
					VisualizationPane.stopUpdating();
					stopGeneratingSpec = true;
					break;
				}
			}
		}

		self.stopGeneratingSpec = stopGeneratingSpec;
	},
	applyBinConstraints: function(shelfNames) {
		const self = this;

		if (self.stopGeneratingSpec)
			return;

		for (let i = 0; i < shelfNames.length; i++) {
			let currentShelfName = shelfNames[i];
			let currentShelfData = Shelf[currentShelfName].getCapsuleData();
			let isCurrentShelfEmpty = Shelf[currentShelfName].isEmpty();

			if (!isCurrentShelfEmpty) {
				let isCurrentShelfQuantitative = currentShelfData.type == 'quantitative';
				let isCurrentShelfNumberOfRecords = 
					currentShelfData.type == 'quantitative' && 
					currentShelfData.attributeName == 'Number of Records' && 
					currentShelfData.isAutoGenerated;

				if (isCurrentShelfQuantitative && !isCurrentShelfNumberOfRecords) {
					currentShelfData.aggregate = 'bin';
					Shelves.refreshCapsules();
				}
			}
		}
	},
	applyYearConstraints: function(shelfNames) {
		const self = this;

		if (self.stopGeneratingSpec)
			return;

		for (let i = 0; i < shelfNames.length; i++) {
			let currentShelfName = shelfNames[i];
			let currentShelfData = Shelf[currentShelfName].getCapsuleData();
			let isCurrentShelfEmpty = Shelf[currentShelfName].isEmpty();

			if (!isCurrentShelfEmpty) {
				let isCurrentShelfTemporal = currentShelfData.type == 'temporal';
				let isCurrentShelfTimeUnitUnset = currentShelfData.timeUnit == 'none';

				if (isCurrentShelfTemporal && isCurrentShelfTimeUnitUnset) {
					currentShelfData.timeUnit = 'year';
					Shelves.refreshCapsules();
				}
			}
		}
	},
	init: function() {
		const self = this;
		let xAxisShelfData = Shelf.xAxis.getCapsuleData();
		let yAxisShelfData = Shelf.yAxis.getCapsuleData();
		let colourShelfData = Shelf.colour.getCapsuleData();
		let rowShelfData = Shelf.row.getCapsuleData();
		let columnShelfData = Shelf.column.getCapsuleData();

		let isXAxisShelfEmpty = Shelf.xAxis.isEmpty();
		let isYAxisShelfEmpty = Shelf.yAxis.isEmpty();
		let isColourShelfEmpty = Shelf.colour.isEmpty();
		let isRowShelfEmpty = Shelf.row.isEmpty();
		let isColumnShelfEmpty = Shelf.column.isEmpty();

		let isXAxisNumberofRecords = isXAxisShelfEmpty ? false : (xAxisShelfData.attributeName == 'Number of Records' && xAxisShelfData.isAutoGenerated);
		let isYAxisNumberofRecords = isYAxisShelfEmpty ? false : (yAxisShelfData.attributeName == 'Number of Records' && yAxisShelfData.isAutoGenerated);

		let distributionAttribute = null;
		let splittingAttributes = null;

		if (isXAxisShelfEmpty || isXAxisNumberofRecords) distributionAttribute = self.createDistributionAttribute(yAxisShelfData);
		if (isYAxisShelfEmpty || isYAxisNumberofRecords) distributionAttribute = self.createDistributionAttribute(xAxisShelfData);
		if (!isColourShelfEmpty || !isRowShelfEmpty || !isColumnShelfEmpty) splittingAttributes = {};
		if (!isColourShelfEmpty) splittingAttributes.color = self.createSplittingAttribute(colourShelfData, 'color');
		if (!isRowShelfEmpty) splittingAttributes.row = self.createSplittingAttribute(rowShelfData, 'row');
		if (!isColumnShelfEmpty) splittingAttributes.column = self.createSplittingAttribute(columnShelfData, 'column');

		self.distributionAttribute = distributionAttribute;
		self.splittingAttributes = splittingAttributes;
	},
	createDistributionAttribute: function(shelfData) {
		let distributionAttribute = {};

		distributionAttribute.name = shelfData.attributeName;
		distributionAttribute.numberOfBins = 15; // default
		distributionAttribute.min = null;
		distributionAttribute.max = null;
		distributionAttribute.binSize = null;
		distributionAttribute.allGroups = null;

		return distributionAttribute;
	},
	createSplittingAttribute: function(shelfData, encodingName) {
		let splittingAttribute = {};

		splittingAttribute.name = null;
		splittingAttribute.encodingName = encodingName;
		splittingAttribute.isQuantitativeBin = (shelfData.type == 'quantitative' && shelfData.aggregate == 'bin');
		splittingAttribute.numberOfBins = null;
		splittingAttribute.min = null;
		splittingAttribute.max = null;
		splittingAttribute.binSize = null;
		splittingAttribute.isTemporal = shelfData.type == 'temporal';
		splittingAttribute.timeUnit = (shelfData.type == 'temporal') ? shelfData.timeUnit : null;
		splittingAttribute.allGroups = null;

		// name
		if (splittingAttribute.isTemporal)
			splittingAttribute.name = shelfData.attributeName + ' (' + splittingAttribute.timeUnit + ')';
		if (!splittingAttribute.isTemporal)
			splittingAttribute.name = shelfData.attributeName;

		// number of bins
		if (splittingAttribute.isQuantitativeBin && shelfData.maxbins == 'none')
			splittingAttribute.numberOfBins = 5; // default
		if (splittingAttribute.isQuantitativeBin && shelfData.maxbins != 'none') 
			splittingAttribute.numberOfBins = shelfData.maxbins;

		return splittingAttribute;
	},

	// get data

	filterData: function() {
		const self = this;
		let splittingAttributes = self.splittingAttributes;
		let distributionAttribute = self.distributionAttribute;
		let dataAfterApplyingFilters = Filters.getFilteredData();
		let dataAfterRemovingMissingValues = [];

		for (let i = 0; i < dataAfterApplyingFilters.length; i++) {
			let currentRow = dataAfterApplyingFilters[i];
			let currentDistributionAttrValue = currentRow[distributionAttribute.name];
			let isDistributionAttrValueMissing = (currentDistributionAttrValue === null);
			let isAtLeastOneSplittingAttrValueMissing = false;

			// find isAtLeastOneSplittingAttrValueMissing
			for (let encodingName in splittingAttributes) {
				let currentSplittingAttribute = splittingAttributes[encodingName];
				let currentSplittingAttrValue = currentRow[currentSplittingAttribute.name];

				if (currentSplittingAttrValue === null) {
					isAtLeastOneSplittingAttrValueMissing = true;
					break;
				}
			}

			// save if none is missing
			if (!(isDistributionAttrValueMissing || isAtLeastOneSplittingAttrValueMissing))
				dataAfterRemovingMissingValues.push(currentRow);
		}

		self.dataAfterFiltering = dataAfterRemovingMissingValues;
	},
	findMinMax: function() {
		const self = this;
		let splittingAttributes = self.splittingAttributes;
		let quantBinSplittingAttributes = [];
		let distributionAttribute = self.distributionAttribute;

		// init
		distributionAttribute.min = Infinity;
		distributionAttribute.max = -Infinity;

		for (let encodingName in splittingAttributes) {
			let currentSplittingAttribute = splittingAttributes[encodingName];

			if (currentSplittingAttribute.isQuantitativeBin) {
				currentSplittingAttribute.min = Infinity;
				currentSplittingAttribute.max = -Infinity;
				quantBinSplittingAttributes.push(currentSplittingAttribute);
			}
		}

		// find min max
		for (let i = 0; i < self.dataAfterFiltering.length; i++) {
			let currentRow = self.dataAfterFiltering[i];
			let currentDistributionAttrValue = +currentRow[distributionAttribute.name];

			// find for distribution attribute
			if (currentDistributionAttrValue < distributionAttribute.min)
				distributionAttribute.min = currentDistributionAttrValue;
			if (currentDistributionAttrValue > distributionAttribute.max)
				distributionAttribute.max = currentDistributionAttrValue;

			// find for splitting attributes
			for (let j = 0; j < quantBinSplittingAttributes.length; j++) {
				let currentSplittingAttribute = quantBinSplittingAttributes[j];
				let currentSplittingAttrValue = +currentRow[currentSplittingAttribute.name];

				if (currentSplittingAttrValue < currentSplittingAttribute.min)
					currentSplittingAttribute.min = currentSplittingAttrValue;
				if (currentSplittingAttrValue > currentSplittingAttribute.max)
					currentSplittingAttribute.max = currentSplittingAttrValue;
			}
		}

		// find bin size
		distributionAttribute.binSize = (distributionAttribute.max - distributionAttribute.min) / distributionAttribute.numberOfBins;

		for (let i = 0; i < quantBinSplittingAttributes.length; i++) {
			let currentSplittingAttribute = quantBinSplittingAttributes[i];
			currentSplittingAttribute.binSize = (currentSplittingAttribute.max - currentSplittingAttribute.min) / currentSplittingAttribute.numberOfBins;
		}
	},

	// group combinations

	generateAllGroupCombinations: function() {
		const self = this;
		let splittingAttributes = self.splittingAttributes;

		if (splittingAttributes !== null) {
			self.findAllGroupsForEachSplittingAttribute();
			self.findAllGroupCombinations();
			self.retrieveObjectsForEachGroup();
		}

		if (splittingAttributes === null)
			self.allGroups = [{
				splittingAttributes: null,
				objects: self.dataAfterFiltering,
				probabilityDistribution: []
			}];
	},
	findAllGroupsForEachSplittingAttribute: function() {
		const self = this;
		let splittingAttributes = self.splittingAttributes;

		for (let encodingName in splittingAttributes) {
			let currentSplittingAttribute = splittingAttributes[encodingName];
			
			if (currentSplittingAttribute.isQuantitativeBin) {
				currentSplittingAttribute.allGroups = [];

				for (let i = 0; i < currentSplittingAttribute.numberOfBins; i++)
					currentSplittingAttribute.allGroups.push(i);
			}

			if (currentSplittingAttribute.isTemporal) {
				let getYear = currentSplittingAttribute.timeUnit == "year";
				let getMonth = currentSplittingAttribute.timeUnit == "month";
				let getWeek = currentSplittingAttribute.timeUnit == "day";
				let timeNameArray = [];
				let timeObject = {};

				for (let i = 0; i < self.dataAfterFiltering.length; i++) {
					let currentRow = self.dataAfterFiltering[i];
					let currentTime = currentRow[currentSplittingAttribute.name];
					let currentTimeString = null;

					if (getYear) currentTimeString = currentTime.toString();
					if (getMonth) currentTimeString = Helpers.getMonthName(currentTime);
					if (getWeek) currentTimeString = Helpers.getWeekdayName(currentTime);
					timeObject[currentTime] = null;
				}

				timeNameArray = Object.keys(timeObject);
				if (getYear) timeNameArray.sort();
				if (getMonth) timeNameArray = Helpers.sortMonthNames(timeNameArray);
				if (getWeek) timeNameArray = Helpers.sortWeekdayNames(timeNameArray);
				currentSplittingAttribute.allGroups = timeNameArray;
			}

			if (!currentSplittingAttribute.isQuantitativeBin && !currentSplittingAttribute.isTemporal) {
				let categoryObject = {};

				for (let i = 0; i < self.dataAfterFiltering.length; i++) {
					let currentRow = self.dataAfterFiltering[i];
					let currentCategory = currentRow[currentSplittingAttribute.name];

					categoryObject[currentCategory] = null;
				}

				currentSplittingAttribute.allGroups = Object.keys(categoryObject);
				currentSplittingAttribute.allGroups.sort();
			}
		}
	},
	findAllGroupCombinations: function() {
		const self = this;
		let splittingAttributes = self.splittingAttributes;
		let splittingAttributeArray = [];
		let numberOfGroupCombinations = 1;
		let allGroupCombinations = [];

		// init
		for (let encodingName in splittingAttributes)
			splittingAttributeArray.push(splittingAttributes[encodingName]);

		for (let i = 0; i < splittingAttributeArray.length; i++) {
			let currentSplittingAttribute = splittingAttributeArray[i];
			let currentMagicNumber = 1;

			if (i > 0) for (let j = 0; j < i; j++) currentMagicNumber *= splittingAttributeArray[j].allGroups.length;
			currentSplittingAttribute.magicNumber = currentMagicNumber;
			numberOfGroupCombinations *= splittingAttributeArray[i].allGroups.length;
		}

		for (let i = 0; i < numberOfGroupCombinations; i++) {
			let groupObject = {
				splittingAttributes: {},
				objects: [],
				probabilityDistribution: []
			};

			allGroupCombinations.push(groupObject);
		}

		// create allGroupCombinations
		for (let i = 0; i < splittingAttributeArray.length; i++) {
			let currentSplittingAttribute = splittingAttributeArray[i];
			let currentSplittingAttrGroupIndex = -1;
			let currentSplittingAttrGroup = null;
			let currentMagicNumber = currentSplittingAttribute.magicNumber;

			for (let j = 0; j < numberOfGroupCombinations; j++) {
				let attributeObject = {};

				// get currentSplittingAttrGroup
				if (j % currentMagicNumber == 0) {
					currentSplittingAttrGroupIndex++;
					currentSplittingAttrGroupIndex = currentSplittingAttrGroupIndex % currentSplittingAttribute.allGroups.length;
					currentSplittingAttrGroup = currentSplittingAttribute.allGroups[currentSplittingAttrGroupIndex];
				}

				// create attribute object
				attributeObject.name = currentSplittingAttribute.name;
				attributeObject.value = currentSplittingAttrGroup;
				allGroupCombinations[j].splittingAttributes[currentSplittingAttribute.encodingName] = attributeObject;			
			}
		}

		self.allGroups = allGroupCombinations;
	},
	retrieveObjectsForEachGroup: function() {
		const self = this;
		let splittingAttributes = self.splittingAttributes;

		for (let i = 0; i < self.dataAfterFiltering.length; i++) {
			let currentRow = self.dataAfterFiltering[i];

			for (let j = 0; j < self.allGroups.length; j++) {
				let currentGroup = self.allGroups[j];
				let satisfyGroupDefinition = true;

				for (let encodingName in currentGroup.splittingAttributes) {
					let currentSplittingAttribute = splittingAttributes[encodingName];
					let currentRowValue = currentRow[currentSplittingAttribute.name];
					let currentRowCategory = null;
					let currentGroupCategory = currentGroup.splittingAttributes[encodingName].value;

					if (currentSplittingAttribute.isQuantitativeBin) {
						currentRowValue = +currentRowValue;
						currentRowCategory = Math.floor((currentRowValue - currentSplittingAttribute.min) / currentSplittingAttribute.binSize);

						if (currentRowCategory >= currentSplittingAttribute.numberOfBins)
							currentRowCategory = currentSplittingAttribute.numberOfBins - 1;
					}

					if (currentSplittingAttribute.isTemporal) {
						let getYear = currentSplittingAttribute.timeUnit == "year";
						let getMonth = currentSplittingAttribute.timeUnit == "month";
						let getWeek = currentSplittingAttribute.timeUnit == "day";

						if (getYear) currentRowCategory = currentRowValue.toString();
						if (getMonth) currentRowCategory = Helpers.getMonthName(currentRowValue);
						if (getWeek) currentRowCategory = Helpers.getWeekdayName(currentRowValue);
					}

					if (!currentSplittingAttribute.isQuantitativeBin && !currentSplittingAttribute.isTemporal)
						currentRowCategory = currentRowValue;

					if (currentRowCategory !== currentGroupCategory) {
						satisfyGroupDefinition = false;
						break;
					}
				}

				if (satisfyGroupDefinition) {
					currentGroup.objects.push(currentRow);
					break;
				}
			}
		}
	},

	// probability distribution

	generateProbDistForEachGroup: function() {
		const self = this;
		let distributionAttribute = self.distributionAttribute;

		// init
		for (let i = 0; i < self.allGroups.length; i++)
			for (let j = 0; j < distributionAttribute.numberOfBins; j++)
				self.allGroups[i].probabilityDistribution.push(0);

		// find probability distribution
		for (let i = 0; i < self.allGroups.length; i++) {
			let currentGroup = self.allGroups[i];

			// find sum of objects that fall into a bin
			for (let j = 0; j < currentGroup.objects.length; j++) {
				let currentRow = currentGroup.objects[j];
				let currentRowDistAttrValue = +currentRow[distributionAttribute.name];
				let currentRowBinIndex = Math.floor((currentRowDistAttrValue - distributionAttribute.min) / distributionAttribute.binSize);

				if (currentRowBinIndex >= distributionAttribute.numberOfBins)
					currentRowBinIndex = distributionAttribute.numberOfBins - 1;

				currentGroup.probabilityDistribution[currentRowBinIndex]++;
			}

			// probability distribution
			if (currentGroup.objects.length > 0)
				for (let j = 0; j < currentGroup.probabilityDistribution.length; j++)
					currentGroup.probabilityDistribution[j] = currentGroup.probabilityDistribution[j] / currentGroup.objects.length;
		}
	},

	// specification

	modifyVegaLiteSpecification: function() {
		const self = this;

		self.initSpecification();
		self.addDataToSpecification();
		self.modifySpecificationWidthAndHeight();
		VegaliteGenerator.specification = self.newSpecification;
	},
	initSpecification: function() {
		const self = this;
		let splittingAttributes = self.splittingAttributes;
		let distributionAttribute = self.distributionAttribute;

		let newSpecification = {};
		let isXAxisDistributionAttr = self.whichAxisIsDistributionAttr() == 'x';
		let orient = isXAxisDistributionAttr ? "vertical" : "horizontal";

		let distributionAttributeSpecification = { field: distributionAttribute.name, type: 'quantitative', scale: { nice: false } };
		let percentageOfRecordsSpecification = { field: 'Percentage of Records', type: 'quantitative', scale: { domain: [ 0, 1 ] }, axis: { format: 'p' } };
		let markSpecification = { type: 'area', interpolate: 'monotone', orient: orient, opacity: 0.4 };

		newSpecification.data = {};
		newSpecification.data.values = [];
		newSpecification.mark = markSpecification;
		newSpecification.encoding = {};
		newSpecification.encoding.x = isXAxisDistributionAttr ? distributionAttributeSpecification : percentageOfRecordsSpecification;
		newSpecification.encoding.y = isXAxisDistributionAttr ? percentageOfRecordsSpecification : distributionAttributeSpecification;
		newSpecification.encoding.tooltip = (splittingAttributes === null) ? { value: false } : [];

		for (let encodingName in splittingAttributes) {
			let currentSplittingAttribute = splittingAttributes[encodingName];
			let attributeName = splittingAttributes[encodingName].name;
			let categoryList = splittingAttributes[encodingName].allGroups;
			let colorScale = (encodingName == 'color') ? self.generateColourScale(attributeName, categoryList) : null;
			let newEncodingSpecification = null;

			newEncodingSpecification = {};
			newEncodingSpecification.field = encodingName;
			newEncodingSpecification.type = 'nominal';
			newEncodingSpecification.axis = { title: currentSplittingAttribute.name };
			if (colorScale !== null) newEncodingSpecification.scale = colorScale; // when encoding is colour

			newSpecification.encoding.tooltip.push(newEncodingSpecification);
			newSpecification.encoding[encodingName] = newEncodingSpecification;
		}

		self.newSpecification = newSpecification;
	},
	addDataToSpecification: function() {
		const self = this;
		let splittingAttributes = self.splittingAttributes;
		let distributionAttribute = self.distributionAttribute;
		let data = [];

		for (let i = 0; i < self.allGroups.length; i++) {
			let currentGroup = self.allGroups[i];

			for (let j = 0; j < currentGroup.probabilityDistribution.length; j++) {
				let probabilityValueObject = {};
				let currentDistributionAttrBinIndex = j;
				let currentDistributionAttrValue = distributionAttribute.min + currentDistributionAttrBinIndex * distributionAttribute.binSize + distributionAttribute.binSize / 2;
				let currentProbabilityValue = currentGroup.probabilityDistribution[j];

				for (let encodingName in currentGroup.splittingAttributes) {
					let currentSplittingAttribute = splittingAttributes[encodingName];
					let currentGroupValue = currentGroup.splittingAttributes[encodingName].value;

					if (currentSplittingAttribute.isQuantitativeBin) {
						let currentBinIndex = currentGroupValue;
						let currentLowerBound = currentSplittingAttribute.min + currentBinIndex * currentSplittingAttribute.binSize;
						let currentUpperBound = currentLowerBound + currentSplittingAttribute.binSize;

						if (currentLowerBound.countDecimals() > 2) currentLowerBound = currentLowerBound.toFixed(2);
						if (currentUpperBound.countDecimals() > 2) currentUpperBound = currentUpperBound.toFixed(2);
						probabilityValueObject[encodingName] = currentLowerBound + ' - ' + currentUpperBound; // use index
					}

					if (!currentSplittingAttribute.isQuantitativeBin)
						probabilityValueObject[encodingName] = currentGroupValue; // use index
				}

				probabilityValueObject[distributionAttribute.name] = currentDistributionAttrValue;
				probabilityValueObject['Percentage of Records'] = currentProbabilityValue;
				data.push(probabilityValueObject);
			}
		}

		self.newSpecification.data.values = data;
	},
	modifySpecificationWidthAndHeight: function() {
		const self = this;
		let width = VegaliteGenerator.specification.width;
		let height = VegaliteGenerator.specification.height;

		self.newSpecification.width = width;
		self.newSpecification.height = height;
	},
	whichAxisIsDistributionAttr: function() {
		let yAxisShelfData = Shelf.yAxis.getCapsuleData();
		let isYAxisEmpty = Shelf.yAxis.isEmpty();
		let isYAxisNumberOfRecords = isYAxisEmpty ? false : yAxisShelfData.attributeName == 'Number of Records' && yAxisShelfData.isAutoGenerated;
		let isXAxisDistributionAttr = (isYAxisEmpty || isYAxisNumberOfRecords);

		return isXAxisDistributionAttr ? 'x' : 'y';
	},
	generateColourScale: function(attributeName, categoryList) { // assuming no missing values in categoryList
		let isOriginallyNominal = (attributeName in Database.categoryToColourDictForEachNominalAttr);
		let categoryToColourDict = isOriginallyNominal ? Database.categoryToColourDictForEachNominalAttr[attributeName] : null;
		let colourCodeList = [];

		if (!isOriginallyNominal)
			return null;

		for (let i = 0; i < categoryList.length; i++) {
			let currentCategory = categoryList[i];
			let currentColourCode = categoryToColourDict[currentCategory];
			colourCodeList.push(currentColourCode);
		}
		return {
			domain: categoryList,
			range: colourCodeList
		};
	}
}